<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Face Alignment（人脸对齐）</title>
      <link href="/2020/05/10/ace-Alignment%EF%BC%88%E4%BA%BA%E8%84%B8%E6%A0%A1%E6%AD%A3%EF%BC%89/"/>
      <url>/2020/05/10/ace-Alignment%EF%BC%88%E4%BA%BA%E8%84%B8%E6%A0%A1%E6%AD%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>我们使用<a href="https://github.com/foamliu/Face-Alignment" target="_blank" rel="noopener">这个仓库</a>进行人脸对齐。</p><p><code>git clone git@github.com:foamliu/Face-Alignment.git</code></p><p>然后我们进入刚下载的文件夹中，对<code>mtcnn.py</code>和<code>align_retinaface.py</code>改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#mtcnn.py</span><br><span class="line"></span><br><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from align_faces import warp_and_crop_face, get_reference_facial_points</span><br><span class="line">from mtcnn.detector import MtcnnDetector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process(img, output_size):</span><br><span class="line">_, facial5points = detector.detect_faces(img)</span><br><span class="line">facial5points = np.reshape(facial5points[0], (2, 5))</span><br><span class="line"></span><br><span class="line">default_square = True</span><br><span class="line">inner_padding_factor = 0.25</span><br><span class="line">outer_padding = (0, 0)</span><br><span class="line"></span><br><span class="line"># get the reference 5 landmarks position in the crop settings</span><br><span class="line">reference_5pts = get_reference_facial_points(</span><br><span class="line">output_size, inner_padding_factor, outer_padding, default_square)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">dst_img = warp_and_crop_face(raw, facial5points, reference_pts=reference_5pts, crop_size=output_size)</span><br><span class="line">return dst_img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">detector = MtcnnDetector()</span><br><span class="line"></span><br><span class="line">for count in range(120):</span><br><span class="line">path = &apos;E:/#Mad-Lab/#DataSet/CV/vggface2_test/test/#new/%04i.jpg&apos; % count</span><br><span class="line">raw = cv.imread(path)</span><br><span class="line"></span><br><span class="line">raw = process(raw, output_size=(224, 224))</span><br><span class="line">raw = raw[78:224-42, 60:224-60]</span><br><span class="line">raw = cv.resize(raw,(112,112))</span><br><span class="line">cv.imwrite(&apos;E:/PythonSoftware/PythonNotebook/Projects/face_recognition/1.face_alignment/Result/delete_sth_r50/%04i.jpg&apos; % count , raw)</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#align_retinaface.py</span><br><span class="line"></span><br><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from align_faces import warp_and_crop_face, get_reference_facial_points</span><br><span class="line">from retinaface.detector import RetinafaceDetector</span><br><span class="line"></span><br><span class="line">def process(img, output_size):</span><br><span class="line">_, facial5points = detector.detect_faces(img)</span><br><span class="line">facial5points = np.reshape(facial5points[0], (2, 5))</span><br><span class="line"></span><br><span class="line">default_square = True</span><br><span class="line">inner_padding_factor = 0.25</span><br><span class="line">outer_padding = (0, 0)</span><br><span class="line"></span><br><span class="line"># get the reference 5 landmarks position in the crop settings</span><br><span class="line">reference_5pts = get_reference_facial_points(</span><br><span class="line">        output_size, inner_padding_factor, outer_padding, default_square)</span><br><span class="line"></span><br><span class="line">dst_img = warp_and_crop_face(raw, facial5points, reference_pts=reference_5pts, crop_size=output_size)</span><br><span class="line">return dst_img</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">detector = RetinafaceDetector()</span><br><span class="line"></span><br><span class="line">for count in range(120):</span><br><span class="line">path = &apos;E:/#Mad-Lab/#DataSet/CV/vggface2_test/test/#new/%04i.jpg&apos; % count</span><br><span class="line">raw = cv.imread(path)</span><br><span class="line">        </span><br><span class="line">raw = process(raw, output_size=(224, 224))</span><br><span class="line">raw = raw[78:224-42, 60:224-60]</span><br><span class="line">raw = cv.resize(raw,(112,112))</span><br><span class="line">cv.imwrite(&apos;E:/PythonSoftware/PythonNotebook/Projects/face_recognition/1.face_alignment/Result/delete_sth_r50/%04i.jpg&apos; % count , raw)</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p>其实主要是把图片路径改成自己的了，然后裁掉了不是人脸的空白区域，最后图片保存为112*112。</p><h1 id="使用MTCNN对齐"><a href="#使用MTCNN对齐" class="headerlink" title="使用MTCNN对齐"></a>使用MTCNN对齐</h1><p><code>python align_mtcnn.py</code></p><h1 id="使用RetunaFace对齐"><a href="#使用RetunaFace对齐" class="headerlink" title="使用RetunaFace对齐"></a>使用RetunaFace对齐</h1><p><code>python align_retinaface.py</code></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img alt="结果" data-src="/images/Pro/FaceAlignment/result.png" class="lazyload"></p><h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>该仓库的网络默认使用的mobilenet0.25，要使用resnet50的话，可以把<strong>Face-Alignment/retinaface/detector.py</strong> 的 class RetinafaceDetector:下面这行改成<code>def __init__(self, net=&#39;resnet50&#39;, type=&#39;cuda&#39;):</code></p><p>此外，还需要下载训练好的resnet50模型（这个<a href="https://github.com/biubug6/Pytorch_Retinaface" target="_blank" rel="noopener">仓库</a>提供了<a href="https://pan.baidu.com/share/init?surl=2h97Fy1RYuqMMIV-RpzdPg" target="_blank" rel="noopener">训练好的模型</a>，密码：fstq），把下载好的Resnet50_Final.pth放到<strong>Face-Alignment/retinaface/weights</strong>下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MMDnn框架转换</title>
      <link href="/2020/05/10/MMDnn%E6%A1%86%E6%9E%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/05/10/MMDnn%E6%A1%86%E6%9E%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>我们可以使用微软的<a href="https://github.com/microsoft/MMdnn" target="_blank" rel="noopener">MMdnn</a>在不同的深度学习框架之间进行转换，比如Tensorflow-&gt;MXNet。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>pip install mmdnn</code>或者<code>pip install -U git+https://github.com/Microsoft/MMdnn.git@master</code></p><h1 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h1><p>比如MXNet转为Tensorflow：</p><h2 id="下载MXNet预训练模型"><a href="#下载MXNet预训练模型" class="headerlink" title="下载MXNet预训练模型"></a>下载MXNet预训练模型</h2><p>先查看有哪些预训练模型可以下载：</p><p><code>mmdownload -f mxnet</code></p><p>然后下载其中的一个模型，比如resnet50：</p><p><code>mmdownload -f mxnet -n imagenet1k-resnet-50 -o ./</code></p><p>可以看到在上前路径下得到了<code>.json</code>和<code>.params</code>文件。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="方法一：一步到位"><a href="#方法一：一步到位" class="headerlink" title="方法一：一步到位"></a>方法一：一步到位</h3><p><code>mmconvert -sf mxnet -in resnet-50-symbol.json -iw resnet-50-0000.params -df tensorflow -om mxnet_resnet50.dnn --inputShape 3,224,224</code><br>可以生成以下几个文件：<br><code>mxnet_resnet50.dnn</code>，<code>.npy</code>和<code>.py</code>文件。</p><h3 id="方法二：一步步转换（便于debug）"><a href="#方法二：一步步转换（便于debug）" class="headerlink" title="方法二：一步步转换（便于debug）"></a>方法二：一步步转换（便于debug）</h3><h4 id="将mxnet模型转成IR模型"><a href="#将mxnet模型转成IR模型" class="headerlink" title="将mxnet模型转成IR模型"></a>将mxnet模型转成IR模型</h4><p>inputShape是输入图像的shape</p><p><code>mmtoir -f mxnet -n ./resnet-50-symbol.json -w ./resnet-50-0000.params -d resnet50 --inputShape 3,224,224</code></p><p>可以得到<code>resnet50.pb</code>，<code>resnet50.npy</code>和<code>resnet50.json</code>文件。</p><h4 id="将IR模型转成Tensorflow的code"><a href="#将IR模型转成Tensorflow的code" class="headerlink" title="将IR模型转成Tensorflow的code"></a>将IR模型转成Tensorflow的code</h4><p><code>mmtocode -f tensorflow --IRModelPath resnet50.pb --IRWeightPath resnet50.npy --dstModelPath mxnet2tf_resnet50.py</code></p><p>可以得到一个<code>mxnet2tf_resnet50.py</code>文件。</p><h4 id="生成pb文件"><a href="#生成pb文件" class="headerlink" title="生成pb文件"></a>生成pb文件</h4><p>基于<code>resnet50.npy</code>和<code>resnet50.py</code>文件，固化参数，生成pb文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import argparse</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import mxnet2tf_resnet50 as tf_fun # modify by yourself</span><br><span class="line"></span><br><span class="line">def Network(ir_model_file):</span><br><span class="line">    model = tf_fun.KitModel(ir_model_file)</span><br><span class="line">    return model</span><br><span class="line"></span><br><span class="line">def freeze_graph(ir_model_file, pb_file):</span><br><span class="line">    output_node_names = &quot;output&quot;</span><br><span class="line">    _,fc1 = Network(ir_model_file)</span><br><span class="line">    fc1 = tf.identity(fc1, name=&quot;output&quot;)</span><br><span class="line"></span><br><span class="line">    graph = tf.get_default_graph()</span><br><span class="line">    input_graph_def = graph.as_graph_def()</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        sess.run(init)</span><br><span class="line">        output_graph_def = tf.graph_util.convert_variables_to_constants(</span><br><span class="line">            sess=sess,</span><br><span class="line">            input_graph_def=input_graph_def,</span><br><span class="line">            output_node_names=output_node_names.split(&quot;,&quot;))</span><br><span class="line"></span><br><span class="line">        with tf.gfile.GFile(pb_file, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(output_graph_def.SerializeToString())</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    parser = argparse.ArgumentParser(description=&apos;freeze model&apos;)</span><br><span class="line">    parser.add_argument(&apos;ir_model_file&apos;, help=&apos;path to ir model, which is *.npy&apos;)</span><br><span class="line">    parser.add_argument(&apos;pb_file&apos;, help=&apos;path to pb file&apos;)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    freeze_graph(args.ir_model_file, args.pb_file)</span><br><span class="line">    print(&quot;finish!&quot;)</span><br></pre></td></tr></table></figure><p>将上面的代码保存为python文件，比如命名为<code>2pb.py</code>再在命令行输入<code>python .\2pb.py resnet50.npy mxnet2tf_resnet50.pb</code>，就可以得到<code>mxnet2tf_resnet50.pb</code>的pb文件。这时候得到pb是可以可视化的，步骤2.1得到的pb文件用Netron打不开，一直提示文件太大，我也不知道为什么。</p><h2 id="模型可视化"><a href="#模型可视化" class="headerlink" title="模型可视化"></a>模型可视化</h2><p>安装<a href="https://github.com/lutzroeder/netron" target="_blank" rel="noopener">Netron</a>：<code>pip install netron</code><br>在命令行输入<code>netron</code>就可以启动啦，然后浏览器输入<code>http://localhost:8080</code>，进入后再打开.pb文件就可以看到模型结构啦。</p><p>当然也可以直接把Netron装电脑上。<br><img alt="模型结构" data-src="/images/Pro/MMdnn/model_structure.png" class="lazyload"><br>另外，模型结构可以保存为svg文件，jpg文件得到的结构不完整，不太清晰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计：基于OpenCV的手势识别系统设计与实现</title>
      <link href="/2019/12/14/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/12/14/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2><ul><li>基于计算指间夹角数量的手势识别模块实现</li><li>基于卷积神经网络的手势识别模块实现</li><li>基于手势的游戏交互应用</li></ul><a id="more"></a><h1 id="1-基于计算指间夹角数量的手势识别模块实现"><a href="#1-基于计算指间夹角数量的手势识别模块实现" class="headerlink" title="1 基于计算指间夹角数量的手势识别模块实现"></a>1 基于计算指间夹角数量的手势识别模块实现</h1><h2 id="1-1-图像预处理模块"><a href="#1-1-图像预处理模块" class="headerlink" title="1.1    图像预处理模块"></a>1.1    图像预处理模块</h2><p>先进行图像预处理减少图像噪声，恢复有用的信息，提高相关信息的可检测性最小化数据，来增强图像分割、匹配和识别的可靠性。</p><p>首先使用基于高斯混合的背景/前景分割算法来去除背景，这里使用<code>OpenCV</code>的内置函数<code>createBackgroundSubtractorMOG2()</code>来去除背景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgModel = cv2.createBackgroundSubtractorMOG2(0, bgSubThreshold)</span><br></pre></td></tr></table></figure><p>然后建立一个背景减法器模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgmask = bgModel.apply(frame)</span><br></pre></td></tr></table></figure><p>将模型运用到每一帧上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = cv2.bitwise_and(frame, frame, mask=fgmask)</span><br></pre></td></tr></table></figure><p>就能得到如图1-1所示的手的前景图像：<br><img alt="img1-1" data-src="/images/Pro/OpenCV0/11.png" class="lazyload"><br>这样得到的图像还不能将想要的手势从复杂的背景中分离出来，所以还需要进行二值化处理。</p><p>先使用<code>cv2.COLOR_BGR2GRAY</code>将RGB图像转化为灰度图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><p>再使用<code>cv2.GaussianBlur()</code>函数用高斯滤波器对图像进行平滑处理，减少噪声：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(gray, (blurValue, blurValue), 0)</span><br></pre></td></tr></table></figure><p>最后通过<code>cv2.threshold()</code>进行阈值处理，使得图像的像素值更单一、图像更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, thresh = cv2.threshold(blur, threshold, 255, cv2.THRESH_BINARY)</span><br></pre></td></tr></table></figure><p>阈值处理是基于特定阈值水平将像素强度分配为0和1，以便仅从图像捕获感兴趣的对象。这样就能从多值的数字图像中直接提取出目标物体。</p><p>设计当按下键盘上的“B”时该模块被触发，实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elif k == ord(&apos;b&apos;):  # press &apos;b&apos; to capture the background</span><br><span class="line">        bgModel = cv2.createBackgroundSubtractorMOG2(0, bgSubThreshold)</span><br><span class="line">        isBgCaptured = 1</span><br><span class="line">        print( &apos;!!!Background Captured!!!&apos;)</span><br></pre></td></tr></table></figure><p>图像预处理结果如图1-2所示：<br><img alt="img1-2" data-src="/images/Pro/OpenCV0/12.png" class="lazyload"></p><h2 id="1-2-轮廓获取模块"><a href="#1-2-轮廓获取模块" class="headerlink" title="1.2 轮廓获取模块"></a>1.2 轮廓获取模块</h2><p>使用<code>cv2.findContours()</code>函数查找检测物体的轮廓，然后通过for循环找到区域内最大的轮廓。再根据图像的轮廓点，通过<code>convexhull()</code>函数转化成凸包的点坐标，从而分别画出手和凸包的轮廓。</p><p>这个函数将从二值图像中找到所有的轮廓：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours,hierarchy=cv2.findContours(thresh1,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure><p>需要得到手基于其面积的最大轮廓，这里可以假设手是最大的轮廓。使用for循环得到该轮廓：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in range(length):</span><br><span class="line">temp = contours[i]</span><br><span class="line">       area = cv2.contourArea(temp)</span><br><span class="line">           if area &gt; maxArea:</span><br><span class="line">               maxArea = area</span><br><span class="line">               ci = i</span><br></pre></td></tr></table></figure><p>根据图像的轮廓点，通过<code>convexHull()</code>函数转化成凸包的点坐标，从而画出图像的凸包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(res)</span><br></pre></td></tr></table></figure><p>分别画出手和凸包的轮廓，如图1-3所示，绿色线条为手的轮廓，红色线条是凸包的轮廓。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(drawing, [res], 0, (0, 255, 0), 2)</span><br><span class="line">cv2.drawContours(drawing, [hull], 0, (0, 0, 255), 5)</span><br></pre></td></tr></table></figure><p>在图1-3中，红色的轮廓线就是凸包<code>(convexity hull)</code>, 而凸包与手掌之间的部分就是凸缺陷<code>(convexity defects)</code>，即对象上的任何凹陷。每个凸缺陷区域有四个特征量：起始点<code>(startPoint)</code>，结束点<code>(endPoint)</code>，距离凸包最远点<code>(farPoint)</code>，最远点到凸包的距离<code>(depth)</code>。如图1-4所示，蓝色的点就是凸缺陷的起始点和结束点，红色的点为最远的点。</p><p><img alt="img1-3" data-src="/images/Pro/OpenCV0/13.jpg" class="lazyload"></p><p><img alt="img1-4" data-src="/images/Pro/OpenCV0/14.png" class="lazyload"><br>最后使用<code>cv.convexityDefect()</code>函数找到凸缺陷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defects = cv2.convexityDefects(res, hull)</span><br></pre></td></tr></table></figure><h2 id="1-3-特征提取模块"><a href="#1-3-特征提取模块" class="headerlink" title="1.3 特征提取模块"></a>1.3 特征提取模块</h2><p>图1-4中大拇指和食指构成的三角形可以具体化为图1-5所示的三角形，设定大拇指和食指的夹角为A，其余两个角为B和C，它们的对边分别为a，b，c。<br>如下代码可以计算三角形每边的长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># find length of all sides of triangle</span><br><span class="line">a = math.sqrt((end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2)</span><br><span class="line">b = math.sqrt((far[0] - start[0]) ** 2 + (far[1] - start[1]) ** 2)</span><br><span class="line">c = math.sqrt((end[0] - far[0]) ** 2 + (end[1] - far[1]) ** 2)</span><br></pre></td></tr></table></figure><p>使用余弦定理的变形公式（公式(1)）计算角A。</p><p>$\cos(A)=(b^2+c^2-a^2)/2bc$   (1)<br><img alt="img1-5" data-src="/images/Pro/OpenCV0/15.jpg" class="lazyload"></p><p>然后使用<code>math.acos()</code>函数获得夹角的反余弦弧度值，通过它可以得到手指间的夹角。如果夹角小于90°就视为是两个手指之间的夹角，通过夹角数量来判断手指个数。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c))  </span><br><span class="line">if angle &lt;= math.pi / 2:</span><br><span class="line">cnt += 1</span><br></pre></td></tr></table></figure><h2 id="1-4-手势识别模块"><a href="#1-4-手势识别模块" class="headerlink" title="1.4 手势识别模块"></a>1.4 手势识别模块</h2><p>当按下键盘上的“N”时，系统开始识别手势类型，实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elif k == ord(&apos;n&apos;):</span><br><span class="line">    triggerSwitch = True</span><br><span class="line">    print (&apos;!!!Trigger On!!!&apos;)</span><br></pre></td></tr></table></figure><p>当该模块被触发时，控制台会输出手势类型，识别代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if triggerSwitch is True:</span><br><span class="line">    if isFinishCal is True:</span><br><span class="line">        print (&quot;finger&quot;+str(cnt+1))# cnt是点的数量，+1表示手指数量</span><br></pre></td></tr></table></figure><h1 id="2-基于卷积神经网络的手势识别模块实现"><a href="#2-基于卷积神经网络的手势识别模块实现" class="headerlink" title="2  基于卷积神经网络的手势识别模块实现"></a>2  基于卷积神经网络的手势识别模块实现</h1><h2 id="2-1-图像预处理及数据集生成模块"><a href="#2-1-图像预处理及数据集生成模块" class="headerlink" title="2.1 图像预处理及数据集生成模块"></a>2.1 图像预处理及数据集生成模块</h2><p>手势识别的第一步是通过消除视频序列中的其他不需要的部分来找到手区域。这里使用的是背景消除法，其原理如图2-1所示。<br>这里让系统查看特定场景30帧，在此期间，计算当前帧和前一帧的运行平均值。通过这样做，告诉系统它盯着的这30帧的平均运行视频序列是背景。在弄清楚背景之后，把手放进去，通过背景消除法让系统理解手是前景对象。计算背景模型（随时间更新）和当前帧（有手的帧）之间的绝对差值，以获得保存新添加的前景对象的差异图像。这就是背景消除法的全部内容。<br>为了从这个差异图像中检测手部区域，需要对差异图像进行阈值处理，以便只有手部区域变得可见，而所有其他不需要的区域都被涂成黑色。这就是运动检测的全部意义所在。<br><img alt="img2-1" data-src="/images/Pro/OpenCV0/16.png" class="lazyload"><br>在对差异图像进行阈值处理后，在得到的图像中找到轮廓，假设面积最大的轮廓是手。<br>因此，从视频序列中找到手区域的第一步涉及三个简单步骤：</p><p>1) 背景消除法 </p><p>2) 运动检测和阈值处理 </p><p>3) 轮廓获取</p><p>现在，将通过代码实现以上步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def run_avg(image, aWeight):</span><br><span class="line">    global bg</span><br><span class="line">    # initialize the background</span><br><span class="line">    if bg is None:</span><br><span class="line">        bg = image.copy().astype(&quot;float&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # compute weighted average, accumulate it and update the background</span><br><span class="line">    cv2.accumulateWeighted(image, bg, aWeight)</span><br></pre></td></tr></table></figure><p><code>run_avg()</code>函数用于计算背景模型和当前帧之间的运行平均值。此函数接受两个参数:当前帧和aWeight，它类似于在图像上执行运行平均值的阈值。如果背景模型为None（即如果它是第一帧），则用当前帧初始化它。然后，使用<code>cv2.accumulateWeighted()</code>函数计算背景模型和当前帧的运行平均值。运行平均值使用式(2)给出的公式计算:</p><p>$dst(x,y)=(1-a).dst(x,y)+a.src(x,y)$  (2)</p><ul><li>src(x,y):源图像或输入图像（1或3通道，8位或32位浮点数）</li><li>dst(x,y):目标图像或输出图像（与源图像相同的通道，32位或64位浮点数）</li><li>a:源图像的权重（输入图像）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def segment(image, threshold=25):</span><br><span class="line">    global bg</span><br><span class="line">    # find the absolute difference between background and current frame</span><br><span class="line">    diff = cv2.absdiff(bg.astype(&quot;uint8&quot;), image)</span><br><span class="line"></span><br><span class="line">    # threshold the diff image so that we get the foreground</span><br><span class="line">    thresholded = cv2.threshold(diff, threshold, 255, cv2.THRESH_BINARY)</span><br><span class="line">    # get the contours in the thresholded image</span><br><span class="line">    (_, cnts, _) = cv2.findContours(thresholded.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    # return None, if no contours detected</span><br><span class="line">    if len(cnts) == 0:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        # based on contour area, get the maximum contour which is the hand</span><br><span class="line">        segmented = max(cnts, key=cv2.contourArea)</span><br><span class="line">        return (thresholded, segmented)</span><br></pre></td></tr></table></figure></li></ul><p>下一个函数<code>segment()</code>是用于从视频序列中分割手区域。此函数包含两个参数：当前帧和阈值，用于对差值图像进行阈值处理。首先，使用<code>cv2.absdiff()</code>函数找到背景模型和当前帧之间的绝对差异。 接下来，使用<code>cv2.threshold()</code>函数对差异图像进行阈值处理以仅显示手部区域。最后，使用<code>cv2.findContours()</code>函数在阈值图像上执行轮廓获取，并获取具有最大面积的轮廓（这是手）。将阈值图像以及分割图像作为元组返回。如果<code>x(n)</code>表示特定像素坐标处的输入图像的像素强度，则<code>threshold</code>决定将图像分割/阈值到二值图像的程度。</p><p>系统必须寻找手区域，因此将尝试最小化识别区域，而不是从整个视频序列中识别手势。要突出显示此区域，使用cv2.rectangle()函数，该函数需要顶部，右侧，底部和左侧像素坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># draw the segmented hand</span><br><span class="line">cv2.rectangle(clone, (left, top), (right, bottom), (0,255,0), 2)</span><br></pre></td></tr></table></figure><p>为了跟踪帧数，初始化变量<code>num_frames</code>。然后，开始一个无限循环，并使用<code>camera.read()</code>函数从网络摄像头读取帧。 然后，将输入帧的大小调整为700像素的固定宽度，使用<code>imutils</code>库保持宽高比并翻转帧以避免镜像视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># get the current frame</span><br><span class="line">(grabbed, frame) = camera.read()</span><br><span class="line"></span><br><span class="line"># resize the frame</span><br><span class="line">frame = imutils.resize(frame, width=700)</span><br><span class="line"></span><br><span class="line"># flip the frame so that it is not the mirror view</span><br><span class="line">frame = cv2.flip(frame, 1)</span><br></pre></td></tr></table></figure><p>接下来，使用简单的<code>NumPy</code>切片仅取出感兴趣的区域（即识别区域）。然后，将此ROI转换为灰度图像，并使用高斯模糊来最小化图像中的高频分量。在超过30帧之前，继续将输入帧添加到<code>run_avg()</code>函数并更新背景模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># get the ROI</span><br><span class="line">roi = frame[top:bottom, right:left]</span><br><span class="line"></span><br><span class="line"># convert the roi to grayscale and blur it</span><br><span class="line">gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)</span><br><span class="line">gray = cv2.GaussianBlur(gray, (7, 7), 0)</span><br><span class="line"></span><br><span class="line"># to get the background, keep looking till a threshold is reached</span><br><span class="line"># so that our running average model gets calibrated</span><br><span class="line">if num_frames &lt; 30:</span><br><span class="line">run_avg(gray, aWeight)</span><br><span class="line">print(num_frames)</span><br></pre></td></tr></table></figure><p>在更新背景模型之后，将当前输入帧传递到<code>segment()</code>函数中，并返回阈值化图像和分割图像。使用<code>cv2.drawContours()</code>在帧上绘制分段轮廓，并使用<code>cv2.imshow()</code>显示阈值输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># segment the hand region</span><br><span class="line">hand = segment(gray)</span><br><span class="line"></span><br><span class="line"># check whether hand region is segmented</span><br><span class="line">if hand is not None:</span><br><span class="line"># if yes, unpack the thresholded image and</span><br><span class="line"># segmented region</span><br><span class="line">        (thresholded, segmented) = hand</span><br><span class="line"></span><br><span class="line">        # draw the segmented region and display the frame</span><br><span class="line">        cv2.drawContours(clone, [segmented + (right, top)], -1, (0, 0, 255))</span><br></pre></td></tr></table></figure><p>最后，在当前帧中显示分割的手势区域如图2-2所示，并等待按键退出程序。<br><img alt="img2-2" data-src="/images/Pro/OpenCV0/17.png" class="lazyload"></p><p>使用如下代码保存图片，每种手势生成1000张图片作为训练集。该模块原本是想作为基于计算指间夹角数量的手势识别模块的补充，识别手势六到十，但是训练集会过于庞大，训练时间太长，值采集了手势零（握拳）、手势五（手掌）和手势六，生成的部分训练数据如图2-3、2-4、2-5所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if start_recording:</span><br><span class="line"># Mention the directory in which you wanna store the images followed by the image name</span><br><span class="line">cv2.imwrite(&quot;Dataset/FistImages/fist_&quot; + str(image_num) + &apos;.png&apos;, thresholded)</span><br><span class="line">image_num += 1</span><br></pre></td></tr></table></figure><p><img alt="img2-3" data-src="/images/Pro/OpenCV0/18.png" class="lazyload"><br><img alt="img2-4" data-src="/images/Pro/OpenCV0/19.png" class="lazyload"><br><img alt="img2-5" data-src="/images/Pro/OpenCV0/20.png" class="lazyload"></p><h2 id="2-2-图像大小调整模块"><a href="#2-2-图像大小调整模块" class="headerlink" title="2.2 图像大小调整模块"></a>2.2 图像大小调整模块</h2><p>使用tensorflow设计的卷积神经网络接受89*100的二维单通道图像,因此需要调整图像大小，使用如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def resizeImage(imageName):</span><br><span class="line">    basewidth = 100</span><br><span class="line">    img = Image.open(imageName)</span><br><span class="line">    wpercent = (basewidth/float(img.size[0]))</span><br><span class="line">    hsize = int((float(img.size[1])*float(wpercent)))</span><br><span class="line">    img = img.resize((basewidth,hsize), Image.ANTIALIAS)</span><br><span class="line">    img.save(imageName)</span><br></pre></td></tr></table></figure><h2 id="2-3-模型训练模块"><a href="#2-3-模型训练模块" class="headerlink" title="2.3 模型训练模块"></a>2.3 模型训练模块</h2><p>本次训练模型使用的是TFLearn，TFLearn建立在tensorflow上的一个深度学习库，提供了基于tensorflow的高层API接口，有助于快速构建深度学习网络，大大减少代码冗余。<br>该神经网络包含7个隐藏卷积层，其中relu作为激活函数，1个全连接层。该网络经过50次迭代的训练，每次的batch size为64。<br>现在来定义网络结构的输入层和隐藏层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">convnet=input_data(shape=[None,89,100,1],name=&apos;input&apos;)</span><br><span class="line">convnet=conv_2d(convnet,32,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,64,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,128,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,256,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,256,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,128,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br><span class="line"></span><br><span class="line">convnet=conv_2d(convnet,64,2,activation=&apos;relu&apos;)</span><br><span class="line">convnet=max_pool_2d(convnet,2)</span><br></pre></td></tr></table></figure><p>再来定义全连接层和输出层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convnet=fully_connected(convnet,1000,activation=&apos;relu&apos;)</span><br><span class="line">convnet=dropout(convnet,0.75)</span><br><span class="line">convnet=fully_connected(convnet,3,activation=&apos;softmax&apos;)</span><br></pre></td></tr></table></figure><p>使用tflearn的DNN类中的fit()函数训练模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.fit(loadedImages, outputVectors, n_epoch=50,</span><br><span class="line">           validation_set = (testImages, testLabels),</span><br><span class="line">           snapshot_step=100, show_metric=True, run_id=&apos;convnet_coursera&apos;)</span><br></pre></td></tr></table></figure><p>然后保存模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.save(&quot;TrainedModel/GestureRecogModel.tfl&quot;)</span><br></pre></td></tr></table></figure><h2 id="2-4-手势识别模块"><a href="#2-4-手势识别模块" class="headerlink" title="2.4 手势识别模块"></a>2.4 手势识别模块</h2><p>先载入之前训练好的模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load(&quot;TrainedModel/GestureRecogModel.tfl&quot;)</span><br></pre></td></tr></table></figure><p><code>prefict()</code>函数可以给定输入数据的模型预测，获得预测的手势种类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction = model.predict([gray_image.reshape(89, 100, 1)])</span><br></pre></td></tr></table></figure><p>然后返回预测的手势类型以及概率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return np.argmax(prediction), (np.amax(prediction) / (prediction[0][0] + prediction[0][1] + prediction[0][2]))</span><br><span class="line">```</span><br><span class="line">将获得的手势编号转化成手势名称：</span><br><span class="line">```</span><br><span class="line">if predictedClass == 0:</span><br><span class="line">className = &quot;Swing&quot;</span><br><span class="line">elif predictedClass == 1:</span><br><span class="line">className = &quot;Palm&quot;</span><br><span class="line">elif predictedClass == 2:</span><br><span class="line">className = &quot;Fist&quot;</span><br></pre></td></tr></table></figure><p>将手势名称及概率显示在屏幕上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv2.putText(textImage,&quot;Pedicted Class : &quot; + className, </span><br><span class="line">    (30, 30),  cv2.FONT_HERSHEY_SIMPLEX,  1,  (255, 255, 255),  2)</span><br><span class="line">    cv2.putText(textImage,&quot;Confidence : &quot; + str(confidence * 100) + &apos;%&apos;, </span><br><span class="line">    (30, 100),  cv2.FONT_HERSHEY_SIMPLEX,  1,  (255, 255, 255), 2)</span><br><span class="line">cv2.imshow(&quot;Statistics&quot;, textImage)</span><br></pre></td></tr></table></figure><p>得到的效果如图2-6所示：<br><img alt="img2-6" data-src="/images/Pro/OpenCV0/21.png" class="lazyload"></p><h1 id="3-基于手势的游戏交互应用"><a href="#3-基于手势的游戏交互应用" class="headerlink" title="3 基于手势的游戏交互应用"></a>3 基于手势的游戏交互应用</h1><p>游戏效果如下图所示：<br><img alt="img3-1" data-src="/images/Pro/OpenCV0/40.png" class="lazyload"><br><img alt="img3-2" data-src="/images/Pro/OpenCV0/41.png" class="lazyload"></p><h1 id="4-手势识别效果演示"><a href="#4-手势识别效果演示" class="headerlink" title="4 手势识别效果演示"></a>4 手势识别效果演示</h1><h2 id="4-1-基于计算指间夹角数量的手势识别模块实现"><a href="#4-1-基于计算指间夹角数量的手势识别模块实现" class="headerlink" title="4.1 基于计算指间夹角数量的手势识别模块实现"></a>4.1 基于计算指间夹角数量的手势识别模块实现</h2><p><img alt="img4-1" data-src="/images/Pro/OpenCV0/30.png" class="lazyload"><br><img alt="img4-2" data-src="/images/Pro/OpenCV0/31.jpg" class="lazyload"><br><img alt="img4-3" data-src="/images/Pro/OpenCV0/32.png" class="lazyload"><br><img alt="img4-4" data-src="/images/Pro/OpenCV0/33.png" class="lazyload"><br><img alt="img4-5" data-src="/images/Pro/OpenCV0/34.jpg" class="lazyload"></p><h2 id="4-2-基于卷积神经网络的手势识别模块实现"><a href="#4-2-基于卷积神经网络的手势识别模块实现" class="headerlink" title="4.2 基于卷积神经网络的手势识别模块实现"></a>4.2 基于卷积神经网络的手势识别模块实现</h2><p><img alt="img4-6" data-src="/images/Pro/OpenCV0/37.png" class="lazyload"><br><img alt="img4-7" data-src="/images/Pro/OpenCV0/38.png" class="lazyload"><br><img alt="img4-8" data-src="/images/Pro/OpenCV0/39.png" class="lazyload"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习实战》-01参考笔记</title>
      <link href="/2019/08/19/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B-01%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/19/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B-01%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本书笔记来源于<a href="https://github.com/apachecn" target="_blank" rel="noopener">Apachecn</a>，该书分为四部分：</p><ol><li>2~7章讲分类</li><li>8~9章讲回归</li><li>10~12章讲无监督学习</li><li>13~15章讲机器学习算法使用到的附属工具</li><li>该笔记增加了第16章推荐系统，作为实战项目</li></ol><a id="more"></a><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.md" target="_blank" rel="noopener">第一章: 机器学习基础</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">第二章: KNN 近邻算法</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/3.%E5%86%B3%E7%AD%96%E6%A0%91.md" target="_blank" rel="noopener">第三章: 决策树</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/4.%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.md" target="_blank" rel="noopener">第四章: 朴素贝叶斯</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/5.Logistic%E5%9B%9E%E5%BD%92.md" target="_blank" rel="noopener">第五章: Logistic回归</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/6.%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.md" target="_blank" rel="noopener">第六章: SVM 支持向量机</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/7.%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%92%8CAdaBoost.md" target="_blank" rel="noopener">第七章: 集成方法（随机森林和 AdaBoost）</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/8.%E5%9B%9E%E5%BD%92.md" target="_blank" rel="noopener">第八章: 回归</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/9.%E6%A0%91%E5%9B%9E%E5%BD%92.md" target="_blank" rel="noopener">第九章: 树回归</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/10.k-means%E8%81%9A%E7%B1%BB.md" target="_blank" rel="noopener">第十章: K-Means 聚类</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/11.%E4%BD%BF%E7%94%A8Apriori%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">第十一章: 利用 Apriori 算法进行关联分析</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/12.%E4%BD%BF%E7%94%A8FP-growth%E7%AE%97%E6%B3%95%E6%9D%A5%E9%AB%98%E6%95%88%E5%8F%91%E7%8E%B0%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86.md" target="_blank" rel="noopener">第十二章: FP-growth 高效发现频繁项集</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/13.%E5%88%A9%E7%94%A8PCA%E6%9D%A5%E7%AE%80%E5%8C%96%E6%95%B0%E6%8D%AE.md" target="_blank" rel="noopener">第十三章: 利用 PCA 来简化数据</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/14.%E5%88%A9%E7%94%A8SVD%E7%AE%80%E5%8C%96%E6%95%B0%E6%8D%AE.md" target="_blank" rel="noopener">第十四章: 利用 SVD 来简化数据</a></p><p><a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/15.%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8EMapReduce.md" target="_blank" rel="noopener">第十五章: 大数据与 MapReduce</a></p><p><a href="https://github.com/apachecn/RecommenderSystems" target="_blank" rel="noopener">第十六章: 推荐系统（已迁移）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习路线</title>
      <link href="/2019/07/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2019/07/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<ul><li>《A Guide to Intelligent Systems》；</li><li>《机器学习》周志华Z1-Z10；</li><li>《Python机器学习及实践》；</li><li>Python&amp;numpy,pandas,matplotlib,sklearn；</li><li><a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="noopener">谷歌机器学习课程</a>；</li><li><a href="https://www.udacity.com/course/intro-to-tensorflow-for-deep-learning--ud187" target="_blank" rel="noopener">Udacity: Intro to TensorFlow for Deep Learning by TensorFlow</a>；</li><li><a href="https://tensorflow.google.cn/tutorials" target="_blank" rel="noopener">Tensorflow</a>；</li><li><a href="https://www.kaggle.com" target="_blank" rel="noopener">Kaggle</a>；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-06Matplotlib</title>
      <link href="/2019/07/16/python-06Matplotlib/"/>
      <url>/2019/07/16/python-06Matplotlib/</url>
      
        <content type="html"><![CDATA[<ul><li>基本介绍</li><li>选择数据</li></ul><a id="more"></a><p><a href="https://matplotlib.org/users/index.html" target="_blank" rel="noopener">Matplotlib</a> 是一个非常强大的 Python 画图工具。它能帮你画出美丽的:</p><blockquote><p>线图，散点图，等高线图，条形图，柱状图，3D 图形，甚至是图形动画等等。</p></blockquote><h1 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h1><p>使用import导入模块matplotlib.pyplot：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>使用np.linspace定义x：范围是(-1,1);个数是50. 仿真一维数据组(x ,y)表示曲线1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用plt.figure定义一个图像窗口，使用plt.plot画(x ,y)曲线，使用plt.show显示图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img1" data-src="/images/python/6.1.png" class="lazyload"></p><h3 id="figure图像"><a href="#figure图像" class="headerlink" title="figure图像"></a>figure图像</h3><p>matplotlib 的 figure 就是一个 单独的 figure 小窗口, 小窗口里面还可以有更多的小图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>使用plt.figure定义一个图像窗口. 使用plt.plot画(x ,y1)曲线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img2" data-src="/images/python/6.2.png" class="lazyload"><br>使用plt.figure定义一个图像窗口：编号为3；大小为(8, 5). 使用plt.plot画(x ,y2)曲线. 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线. 使用plt.show显示图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(num=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">5</span>),)</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.plot(x, y1, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img3" data-src="/images/python/6.3.png" class="lazyload"></p><h3 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h3><h5 id="调整名字和间隔"><a href="#调整名字和间隔" class="headerlink" title="调整名字和间隔"></a>调整名字和间隔</h5><p>使用np.linspace定义x：范围是(-3,3);个数是50. 仿真一维数据组(x ,y1)表示曲线1. 仿真一维数据组(x ,y2)表示曲线2.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>使用plt.figure定义一个图像窗口. 使用plt.plot画(x ,y2)曲线. 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.plot(x, y1, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>)</span><br></pre></td></tr></table></figure><p>使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)； 使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim((<span class="number">-1</span>, <span class="number">2</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">'I am x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'I am y'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img4" data-src="/images/python/6.4.png" class="lazyload"><br>使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_ticks = np.linspace(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(new_ticks)</span><br><span class="line">plt.xticks(new_ticks)</span><br></pre></td></tr></table></figure><p>使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.yticks([<span class="number">-2</span>, <span class="number">-1.8</span>, <span class="number">-1</span>, <span class="number">1.22</span>, <span class="number">3</span>],[<span class="string">r'$really\ bad$'</span>, <span class="string">r'$bad$'</span>, <span class="string">r'$normal$'</span>, <span class="string">r'$good$'</span>, <span class="string">r'$really\ good$'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img5" data-src="/images/python/6.5.png" class="lazyload"></p><h5 id="设置不同名字和位置"><a href="#设置不同名字和位置" class="headerlink" title="设置不同名字和位置"></a>设置不同名字和位置</h5><p>使用np.linspace定义x：范围是(-3,3);个数是50. 仿真一维数据组(x ,y1)表示曲线1. 仿真一维数据组(x ,y2)表示曲线2.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-3</span>,<span class="number">3</span>,<span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.plot(x,y1,color=<span class="string">'red'</span>,linewidth=<span class="number">1.0</span>,linestyle=<span class="string">'--'</span>)</span><br><span class="line">plt.xlim((<span class="number">-1</span>,<span class="number">2</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5. 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’].</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_ticks = np.linspace(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line">plt.yticks([<span class="number">-2</span>,<span class="number">-1.8</span>,<span class="number">-1</span>,<span class="number">1.22</span>,<span class="number">3</span>],[<span class="string">'$really\ bad$'</span>,<span class="string">'$bad$'</span>,<span class="string">'$normal$'</span>,<span class="string">'$good$'</span>,<span class="string">'$really\ good$'</span>])</span><br></pre></td></tr></table></figure><p>使用plt.gca获取当前坐标轴信息。使用.spines设置边框：</p><p>右侧边框，使用.set_color设置边框颜色：默认白色； </p><p>上边框，使用.set_color设置边框颜色：默认白色；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img6" data-src="/images/python/6.6.png" class="lazyload"></p><h5 id="调整坐标轴"><a href="#调整坐标轴" class="headerlink" title="调整坐标轴"></a>调整坐标轴</h5><p>使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom（所有位置：top，bottom，both，default，none）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br></pre></td></tr></table></figure><p>使用.spines设置边框：x轴；使用.set_position设置边框位置在y=0处；（位置所有属性：outward，axes，data）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>同理，设置y轴的刻度和坐标的位置：·</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img7" data-src="/images/python/6.7.png" class="lazyload"></p><p>本节参考自莫烦python，学习请点击：<a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/plt/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-05Pandas</title>
      <link href="/2019/07/15/python-05Pandas/"/>
      <url>/2019/07/15/python-05Pandas/</url>
      
        <content type="html"><![CDATA[<ul><li>基本介绍</li><li>选择数据</li><li>设置值</li><li>处理丢失数据</li><li>导入导出</li><li>合并concat</li><li>合并merge</li><li>plot出图</li></ul><a id="more"></a><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 <a href="https://pandas.pydata.org/pandas-docs/stable/" target="_blank" rel="noopener">Pandas</a> 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p><p>要使用pandas，首先需要了解他主要两个数据结构：Series和DataFrame。</p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series的字符串表现形式为：索引在左边，值在右边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为长度）的整数型索引。</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20160101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   a         b         c         d</span></span><br><span class="line"><span class="string">2016-01-01 -0.253065 -2.071051 -0.640515  0.613663</span></span><br><span class="line"><span class="string">2016-01-02 -1.147178  1.532470  0.989255 -0.499761</span></span><br><span class="line"><span class="string">2016-01-03  1.221656 -2.390171  1.862914  0.778070</span></span><br><span class="line"><span class="string">2016-01-04  1.473877 -0.046419  0.610046  0.204672</span></span><br><span class="line"><span class="string">2016-01-05 -1.584752 -0.700592  1.487264 -1.778293</span></span><br><span class="line"><span class="string">2016-01-06  0.633675 -1.414157 -0.277066 -0.442545</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>可以根据每一个不同的索引来挑选数据, 比如挑选 b 的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'b'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2016-01-01   -2.071051</span></span><br><span class="line"><span class="string">2016-01-02    1.532470</span></span><br><span class="line"><span class="string">2016-01-03   -2.390171</span></span><br><span class="line"><span class="string">2016-01-04   -0.046419</span></span><br><span class="line"><span class="string">2016-01-05   -0.700592</span></span><br><span class="line"><span class="string">2016-01-06   -1.414157</span></span><br><span class="line"><span class="string">Freq: D, Name: b, dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>创建一组没有给定行标签和列标签的数据 df1，它就会采取默认的从0开始 index:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   0  1   2   3</span></span><br><span class="line"><span class="string">0  0  1   2   3</span></span><br><span class="line"><span class="string">1  4  5   6   7</span></span><br><span class="line"><span class="string">2  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p> 还有一种生成 df 的方法, 如下 df2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">                    <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">                    <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">                    <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">                    <span class="string">'F'</span> : <span class="string">'foo'</span>&#125;)</span><br><span class="line">print(df2)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想要查看数据中的类型, 我们可以用 dtype 这个属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A           float64</span></span><br><span class="line"><span class="string">B    datetime64[ns]</span></span><br><span class="line"><span class="string">C           float32</span></span><br><span class="line"><span class="string">D             int32</span></span><br><span class="line"><span class="string">E          category</span></span><br><span class="line"><span class="string">F            object</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想看对列的序号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br><span class="line"><span class="comment"># Int64Index([0, 1, 2, 3], dtype='int64')</span></span><br></pre></td></tr></table></figure><p>每种数据的名称也能看到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df2.columns)</span><br><span class="line"><span class="comment"># Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')</span></span><br></pre></td></tr></table></figure><p>如果只想看所有df2的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>想知道数据的总结, 可以用 describe():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">         A    C    D</span></span><br><span class="line"><span class="string">count  4.0  4.0  4.0</span></span><br><span class="line"><span class="string">mean   1.0  1.0  3.0</span></span><br><span class="line"><span class="string">std    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">min    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">25%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">50%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">75%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">max    1.0  1.0  3.0</span></span><br></pre></td></tr></table></figure><p>如果想翻转数据, transpose:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br><span class="line"><span class="string">"""                   </span></span><br><span class="line"><span class="string">0                    1                    2  \</span></span><br><span class="line"><span class="string">A                    1                    1                    1   </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   </span></span><br><span class="line"><span class="string">C                    1                    1                    1   </span></span><br><span class="line"><span class="string">D                    3                    3                    3   </span></span><br><span class="line"><span class="string">E                 test                train                 test   </span></span><br><span class="line"><span class="string">F                  foo                  foo                  foo   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     3  </span></span><br><span class="line"><span class="string">A                    1  </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  </span></span><br><span class="line"><span class="string">C                    1  </span></span><br><span class="line"><span class="string">D                    3  </span></span><br><span class="line"><span class="string">E                train  </span></span><br><span class="line"><span class="string">F                  foo  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果想对数据的 index 进行排序并输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按列倒序排序</span></span><br><span class="line">df2.sort_index(axis=<span class="number">1</span>,ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     F      E  D    C          B    A</span></span><br><span class="line"><span class="string">0  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">1  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">2  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">3  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行倒序排序</span></span><br><span class="line">df2.sort_index(axis=<span class="number">0</span>,ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果是对数据值排序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df2.sort_values(by=<span class="string">'E'</span>)</span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">2</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</span><br><span class="line"><span class="number">3</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</span><br></pre></td></tr></table></figure><h1 id="二、选择数据"><a href="#二、选择数据" class="headerlink" title="二、选择数据"></a>二、选择数据</h1><p>建立了一个 6X4 的矩阵数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20190721'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2019-07-21   0   1   2   3</span></span><br><span class="line"><span class="string">2019-07-22   4   5   6   7</span></span><br><span class="line"><span class="string">2019-07-23   8   9  10  11</span></span><br><span class="line"><span class="string">2019-07-24  12  13  14  15</span></span><br><span class="line"><span class="string">2019-07-25  16  17  18  19</span></span><br><span class="line"><span class="string">2019-07-26  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="简单的筛选"><a href="#简单的筛选" class="headerlink" title="简单的筛选"></a>简单的筛选</h3><p>如果我们想选取DataFrame中的数据，下面描述了两种途径, 他们都能达到同一个目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'A'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2019-07-21     0</span></span><br><span class="line"><span class="string">2019-07-22     4</span></span><br><span class="line"><span class="string">2019-07-23     8</span></span><br><span class="line"><span class="string">2019-07-24    12</span></span><br><span class="line"><span class="string">2019-07-25    16</span></span><br><span class="line"><span class="string">2019-07-26    20</span></span><br><span class="line"><span class="string">Freq: D, Name: A, dtype: int32</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.A</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2019-07-21     0</span></span><br><span class="line"><span class="string">2019-07-22     4</span></span><br><span class="line"><span class="string">2019-07-23     8</span></span><br><span class="line"><span class="string">2019-07-24    12</span></span><br><span class="line"><span class="string">2019-07-25    16</span></span><br><span class="line"><span class="string">2019-07-26    20</span></span><br><span class="line"><span class="string">Freq: D, Name: A, dtype: int32</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>让选择跨越多行或多列:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A  B   C   D</span></span><br><span class="line"><span class="string">2019-07-21  0  1   2   3</span></span><br><span class="line"><span class="string">2019-07-22  4  5   6   7</span></span><br><span class="line"><span class="string">2019-07-23  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 选择20190722到20190725标签之间的数据，并且包括这两个标签</span></span><br><span class="line">df[<span class="string">'20190722'</span>:<span class="string">'20190725'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2019-07-22   4   5   6   7</span></span><br><span class="line"><span class="string">2019-07-23   8   9  10  11</span></span><br><span class="line"><span class="string">2019-07-24  12  13  14  15</span></span><br><span class="line"><span class="string">2019-07-25  16  17  18  19</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据标签-loc"><a href="#根据标签-loc" class="headerlink" title="根据标签 loc"></a>根据标签 loc</h3><p>使用<code>loc</code>通过标签名字选择某一行数据，或者通过选择某行或者所有行（:代表所有行）然后选其中某一列或几列数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">'20190722'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    4</span></span><br><span class="line"><span class="string">B    5</span></span><br><span class="line"><span class="string">C    6</span></span><br><span class="line"><span class="string">D    7</span></span><br><span class="line"><span class="string">Name: 2019-07-22 00:00:00, dtype: int32</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B</span></span><br><span class="line"><span class="string">2019-07-21   0   1</span></span><br><span class="line"><span class="string">2019-07-22   4   5</span></span><br><span class="line"><span class="string">2019-07-23   8   9</span></span><br><span class="line"><span class="string">2019-07-24  12  13</span></span><br><span class="line"><span class="string">2019-07-25  16  17</span></span><br><span class="line"><span class="string">2019-07-26  20  21</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据序列-iloc"><a href="#根据序列-iloc" class="headerlink" title="根据序列 iloc"></a>根据序列 iloc</h3><p>使用<code>iloc</code>通过位置选择在不同情况下所需要的数据。例如选某一个，连续选或者跨行选等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    12</span></span><br><span class="line"><span class="string">B    13</span></span><br><span class="line"><span class="string">C    14</span></span><br><span class="line"><span class="string">D    15</span></span><br><span class="line"><span class="string">Name: 2019-07-24 00:00:00, dtype: int32</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.iloc[<span class="number">3</span>,<span class="number">1</span>] <span class="comment"># 13</span></span><br><span class="line">df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C</span></span><br><span class="line"><span class="string">2019-07-24  12  13  14</span></span><br><span class="line"><span class="string">2019-07-25  16  17  18</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C</span></span><br><span class="line"><span class="string">2019-07-22   4   5   6</span></span><br><span class="line"><span class="string">2019-07-24  12  13  14</span></span><br><span class="line"><span class="string">2019-07-26  20  21  22</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="混合选择-ix"><a href="#混合选择-ix" class="headerlink" title="混合选择 ix"></a>混合选择 ix</h3><p>可以采用混合选择<code>ix</code>, 其中选择’A’和’C’的两列，并选择前三行的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.ix[:<span class="number">3</span>,[<span class="string">'A'</span>,<span class="string">'C'</span>]]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A   C</span></span><br><span class="line"><span class="string">2019-07-21  0   2</span></span><br><span class="line"><span class="string">2019-07-22  4   6</span></span><br><span class="line"><span class="string">2019-07-23  8  10</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="通过判断的筛选"><a href="#通过判断的筛选" class="headerlink" title="通过判断的筛选"></a>通过判断的筛选</h3><p>可以采用判断指令 (Boolean indexing)约束某项条件然后选择出当前所有数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df[df.A&gt;<span class="number">8</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2019-07-24  12  13  14  15</span></span><br><span class="line"><span class="string">2019-07-25  16  17  18  19</span></span><br><span class="line"><span class="string">2019-07-26  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="三、设置值"><a href="#三、设置值" class="headerlink" title="三、设置值"></a>三、设置值</h1><h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><p>首先建立了一个 6X4 的矩阵数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   1   2   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5   6   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9  10  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17  18  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>根据位置设置 loc 和 iloc<br>我们可以利用索引或者标签确定需要修改值的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">2</span>,<span class="number">2</span>] = <span class="number">1111</span></span><br><span class="line">df.loc[<span class="string">'20130101'</span>,<span class="string">'B'</span>] = <span class="number">2222</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7</span></span><br><span class="line"><span class="string">2013-01-03   8     9  1111  11</span></span><br><span class="line"><span class="string">2013-01-04  12    13    14  15</span></span><br><span class="line"><span class="string">2013-01-05  16    17    18  19</span></span><br><span class="line"><span class="string">2013-01-06  20    21    22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据条件设置"><a href="#根据条件设置" class="headerlink" title="根据条件设置"></a>根据条件设置</h3><p>如果现在的判断条件是这样, 对于A大于4的行，更改df在相应行上的所有数为9999。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df[df.A&gt;<span class="number">4</span>] = <span class="number">9999</span></span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">               A     B     C     D</span></span><br><span class="line"><span class="string">2019-07-21     0     1     2     3</span></span><br><span class="line"><span class="string">2019-07-22     4  2222     6     7</span></span><br><span class="line"><span class="string">2019-07-23  9999  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-24  9999  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-25  9999  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-26  9999  9999  9999  9999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>将A列中所有大于9998的值都改为9：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.A[df.A&gt;<span class="number">9998</span>]=<span class="number">9</span></span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A     B     C     D</span></span><br><span class="line"><span class="string">2019-07-21  0     1     2     3</span></span><br><span class="line"><span class="string">2019-07-22  4  2222     6     7</span></span><br><span class="line"><span class="string">2019-07-23  9  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-24  9  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-25  9  9999  9999  9999</span></span><br><span class="line"><span class="string">2019-07-26  9  9999  9999  9999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>对于A大于8的位置，更改B在相应位置上的数为9。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.B[df.A&gt;<span class="number">8</span>]=<span class="number">9</span></span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A     B     C     D</span></span><br><span class="line"><span class="string">2019-07-21  0     1     2     3</span></span><br><span class="line"><span class="string">2019-07-22  4  2222     6     7</span></span><br><span class="line"><span class="string">2019-07-23  9     9  9999  9999</span></span><br><span class="line"><span class="string">2019-07-24  9     9  9999  9999</span></span><br><span class="line"><span class="string">2019-07-25  9     9  9999  9999</span></span><br><span class="line"><span class="string">2019-07-26  9     9  9999  9999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="按行或列设置"><a href="#按行或列设置" class="headerlink" title="按行或列设置"></a>按行或列设置</h3><p>如果对整列做批处理, 加上一列 ‘F’, 并将 F 列全改为 NaN, 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'F'</span>]=np.nan</span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A     B     C     D   F</span></span><br><span class="line"><span class="string">2019-07-21  0     1     2     3 NaN</span></span><br><span class="line"><span class="string">2019-07-22  4  2222     6     7 NaN</span></span><br><span class="line"><span class="string">2019-07-23  9     9  9999  9999 NaN</span></span><br><span class="line"><span class="string">2019-07-24  9     9  9999  9999 NaN</span></span><br><span class="line"><span class="string">2019-07-25  9     9  9999  9999 NaN</span></span><br><span class="line"><span class="string">2019-07-26  9     9  9999  9999 NaN</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>用上面的方法也可以加上 Series 序列（但是长度必须对齐）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'E'</span>]=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],index=pd.date_range(<span class="string">'20190721'</span>,periods=<span class="number">6</span>))</span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A     B     C     D   F  E</span></span><br><span class="line"><span class="string">2019-07-21  0     1     2     3 NaN  1</span></span><br><span class="line"><span class="string">2019-07-22  4  2222     6     7 NaN  2</span></span><br><span class="line"><span class="string">2019-07-23  9     9  9999  9999 NaN  3</span></span><br><span class="line"><span class="string">2019-07-24  9     9  9999  9999 NaN  4</span></span><br><span class="line"><span class="string">2019-07-25  9     9  9999  9999 NaN  5</span></span><br><span class="line"><span class="string">2019-07-26  9     9  9999  9999 NaN  6</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="四、处理丢失数据"><a href="#四、处理丢失数据" class="headerlink" title="四、处理丢失数据"></a>四、处理丢失数据</h1><h3 id="创建含-NaN-的矩阵"><a href="#创建含-NaN-的矩阵" class="headerlink" title="创建含 NaN 的矩阵"></a>创建含 NaN 的矩阵</h3><p>有时候我们导入或处理数据, 会产生一些空的或者是 NaN 数据。建立一个6X4的矩阵数据并且把两个位置置为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>] = np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = np.nan</span><br><span class="line">df</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   NaN   2.0   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5.0   NaN   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="pd-dropna"><a href="#pd-dropna" class="headerlink" title="pd.dropna()"></a>pd.dropna()</h3><p>如果想直接去掉有 NaN 的行或列, 可以使用 dropna：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(</span><br><span class="line">    axis=<span class="number">0</span>,     <span class="comment"># 0: 对行进行操作; 1: 对列进行操作</span></span><br><span class="line">    how=<span class="string">'any'</span>   <span class="comment"># 'any': 只要存在 NaN 就 drop 掉; 'all': 必须全部是 NaN 才 drop </span></span><br><span class="line">    )</span><br><span class="line"><span class="string">"""    </span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="pd-fillna"><a href="#pd-fillna" class="headerlink" title="pd.fillna()"></a>pd.fillna()</h3><p>如果是将 NaN 的值用其他值代替, 比如代替成 0:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   0.0   2.0   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5.0   0.0   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="pd-isnull"><a href="#pd-isnull" class="headerlink" title="pd.isnull()"></a>pd.isnull()</h3><p>判断是否有缺失数据 NaN, 为 True 表示缺失数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.isnull()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                A      B      C      D</span></span><br><span class="line"><span class="string">2013-01-01  False   True  False  False</span></span><br><span class="line"><span class="string">2013-01-02  False  False   True  False</span></span><br><span class="line"><span class="string">2013-01-03  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-04  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-05  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-06  False  False  False  False</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>检测在数据中是否存在 NaN, 如果存在就返回 True:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.any(df.isnull()) == <span class="literal">True</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><h1 id="五、导入导出"><a href="#五、导入导出" class="headerlink" title="五、导入导出"></a>五、导入导出</h1><p>pandas可以读取与存取的资料格式有很多种，像csv、excel、json、html与pickle等…，详细请看<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" target="_blank" rel="noopener">官方说明文件</a></p><h3 id="读取csv"><a href="#读取csv" class="headerlink" title="读取csv"></a>读取csv</h3><p>示范档案下载 - <a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/15_read_to/student.csv" target="_blank" rel="noopener">student.csv</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment">#加载模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取csv</span></span><br><span class="line">data = pd.read_csv(<span class="string">'D:\B\hexo\source\_posts\student.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印出data</span></span><br><span class="line">print(data)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"> Student ID  name    age  gender</span></span><br><span class="line"><span class="string">0       1100.0  Kelly  22.0  Female</span></span><br><span class="line"><span class="string">1       1101.0    Clo  21.0  Female</span></span><br><span class="line"><span class="string">2       1102.0  Tilly  22.0  Female</span></span><br><span class="line"><span class="string">3       1103.0   Tony  24.0    Male</span></span><br><span class="line"><span class="string">4       1104.0  David  20.0    Male</span></span><br><span class="line"><span class="string">5       1105.0  Catty  22.0  Female</span></span><br><span class="line"><span class="string">6       1106.0      M   3.0  Female</span></span><br><span class="line"><span class="string">7       1107.0      N  43.0    Male</span></span><br><span class="line"><span class="string">8       1108.0      A  13.0    Male</span></span><br><span class="line"><span class="string">9       1109.0      S  12.0    Male</span></span><br><span class="line"><span class="string">10      1110.0  David  33.0    Male</span></span><br><span class="line"><span class="string">11      1111.0     Dw   3.0  Female</span></span><br><span class="line"><span class="string">12      1112.0      Q  23.0    Male</span></span><br><span class="line"><span class="string">13      1113.0      W  21.0  Female</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="将资料存取成其他格式"><a href="#将资料存取成其他格式" class="headerlink" title="将资料存取成其他格式"></a>将资料存取成其他格式</h3><p>比如保存成pickle文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.to_pickle(<span class="string">"D:\B\hexo\source\_posts\student.pickle"</span>)</span><br></pre></td></tr></table></figure><p>就可以看到文件夹下产生了一个pickle文件：<br><img alt="img1" data-src="/images/python/5.1.png" class="lazyload"></p><h1 id="六、合并-concat"><a href="#六、合并-concat" class="headerlink" title="六、合并 concat"></a>六、合并 concat</h1><p>使用 concat是一种基本的合并方式.而且concat中有很多参数可以调整,合并成你想要的数据形式。</p><h3 id="axis-合并方向"><a href="#axis-合并方向" class="headerlink" title="axis(合并方向)"></a>axis(合并方向)</h3><p>axis=0是预设值，因此未设定任何参数时，函数默认axis=0，即按行合并（纵向）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义数据集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#concat纵向合并</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    a    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">1  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">2  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">0  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">1  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">2  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="ignore-index-重置-index"><a href="#ignore-index-重置-index" class="headerlink" title="ignore_index(重置 index)"></a>ignore_index(重置 index)</h3><p>仔细观察会发现结果的index是0, 1, 2, 0, 1, 2, 0, 1, 2，若要将index重置，需要加上参数ignore_index (重置 index)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#承上一个例子，并将index_ignore设定为True</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    a    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">6  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">7  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">8  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>结果的index变0, 1, 2, 3, 4, 5, 6, 7, 8。</p><h3 id="join-合并方式"><a href="#join-合并方式" class="headerlink" title="join(合并方式)"></a>join(合并方式)</h3><p>join=’outer’为预设值，因此未设定任何参数时，函数默认join=’outer’。此方式是依照column来做纵向合并，有相同的column上下合并在一起，其他独自的column个自成列，原本没有值的位置皆以NaN填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#纵向"外"合并df1与df2</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'outer'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    a    b    c    d    e</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="string">3  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="string">2  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">3  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>承上一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#纵向"内"合并df1与df2</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'inner'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    b    c    d</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">3  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重置index并打印结果</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'inner'</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">5  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="join-axes-依照-axes-合并"><a href="#join-axes-依照-axes-合并" class="headerlink" title="join_axes(依照 axes 合并)"></a>join_axes(依照 axes 合并)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义数据集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#依照`df1.index`进行横向合并</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">1</span>, join_axes=[df1.index])</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a    b    c    d    b    c    d    e</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="append-添加数据"><a href="#append-添加数据" class="headerlink" title="append(添加数据)"></a>append(添加数据)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义数据集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将df2合并到df1的下面，以及重置index，并打印出结果</span></span><br><span class="line">res = df1.append(df2,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    a    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并多个df，将df2与df3合并至df1的下面，以及重置index，并打印出结果</span></span><br><span class="line">res = df1.append([df2,df3],ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     a    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="string">6  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">7  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">8  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并series，将s1合并至df1，以及重置index，并打印出结果</span></span><br><span class="line">s1 = pd.Series([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],ignore_index+<span class="literal">True</span>)</span><br><span class="line">s1 = pd.Series([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">res = df1.append(s1,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     a    b    c    d</span></span><br><span class="line"><span class="string">0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  3.0  3.0  3.0  3.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="七、合并merge"><a href="#七、合并merge" class="headerlink" title="七、合并merge"></a>七、合并merge</h1><p>pandas中的merge和concat类似,但主要是用于两组有key column的数据,统一索引的数据. 通常也被用在Database的处理当中。</p><h3 id="依据一组key合并"><a href="#依据一组key合并" class="headerlink" title="依据一组key合并"></a>依据一组key合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                             <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                             <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                              <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                              <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1 key2   A   B</span></span><br><span class="line"><span class="string">0   K0   K0  A0  B0</span></span><br><span class="line"><span class="string">1   K0   K1  A1  B1</span></span><br><span class="line"><span class="string">2   K1   K0  A2  B2</span></span><br><span class="line"><span class="string">3   K2   K1  A3  B3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(right)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1 key2   C   D</span></span><br><span class="line"><span class="string">0   K0   K0  C0  D0</span></span><br><span class="line"><span class="string">1   K1   K0  C1  D1</span></span><br><span class="line"><span class="string">2   K1   K0  C2  D2</span></span><br><span class="line"><span class="string">3   K2   K0  C3  D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据key column合并，并打印出</span></span><br><span class="line">res = pd.merge(left,right,on=<span class="string">'key'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key   A   B   C   D</span></span><br><span class="line"><span class="string">0  K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="string">1  K0  A1  B1  C0  D0</span></span><br><span class="line"><span class="string">2  K1  A2  B2  C1  D1</span></span><br><span class="line"><span class="string">3  K1  A2  B2  C2  D2</span></span><br><span class="line"><span class="string">4  K2  A3  B3  C3  D3</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="依据两组key合并"><a href="#依据两组key合并" class="headerlink" title="依据两组key合并"></a>依据两组key合并</h3><p>合并时有4种方法how = [‘left’, ‘right’, ‘outer’, ‘inner’]，预设值how=’inner’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">     <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>],</span><br><span class="line">                      <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                      <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                       <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>],</span><br><span class="line">                       <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                       <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line">left</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2   A   B</span></span><br><span class="line"><span class="string">0   K0   K0  A0  B0</span></span><br><span class="line"><span class="string">1   K0   K1  A1  B1</span></span><br><span class="line"><span class="string">2   K1   K0  A2  B2</span></span><br><span class="line"><span class="string">3   K2   K1  A3  B3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">right</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2   C   D</span></span><br><span class="line"><span class="string">0   K0   K0  C0  D0</span></span><br><span class="line"><span class="string">1   K1   K0  C1  D1</span></span><br><span class="line"><span class="string">2   K1   K0  C2  D2</span></span><br><span class="line"><span class="string">3   K2   K0  C3  D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>])</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2   A   B   C   D</span></span><br><span class="line"><span class="string">0   K0   K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="string">1   K1   K0  A2  B2  C1  D1</span></span><br><span class="line"><span class="string">2   K1   K0  A2  B2  C2  D2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据key1与key2 columns进行合并，并打印出四种结果['left', 'right', 'outer', 'inner']</span></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'inner'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2   A   B   C   D</span></span><br><span class="line"><span class="string">0   K0   K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="string">1   K1   K0  A2  B2  C1  D1</span></span><br><span class="line"><span class="string">2   K1   K0  A2  B2  C2  D2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'outer'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2    A    B    C    D</span></span><br><span class="line"><span class="string">0   K0   K0   A0   B0   C0   D0</span></span><br><span class="line"><span class="string">1   K0   K1   A1   B1  NaN  NaN</span></span><br><span class="line"><span class="string">2   K1   K0   A2   B2   C1   D1</span></span><br><span class="line"><span class="string">3   K1   K0   A2   B2   C2   D2</span></span><br><span class="line"><span class="string">4   K2   K1   A3   B3  NaN  NaN</span></span><br><span class="line"><span class="string">5   K2   K0  NaN  NaN   C3   D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'right'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2    A    B   C   D</span></span><br><span class="line"><span class="string">0   K0   K0   A0   B0  C0  D0</span></span><br><span class="line"><span class="string">1   K1   K0   A2   B2  C1  D1</span></span><br><span class="line"><span class="string">2   K1   K0   A2   B2  C2  D2</span></span><br><span class="line"><span class="string">3   K2   K0  NaN  NaN  C3  D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'left'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  key1 key2   A   B    C    D</span></span><br><span class="line"><span class="string">0   K0   K0  A0  B0   C0   D0</span></span><br><span class="line"><span class="string">1   K0   K1  A1  B1  NaN  NaN</span></span><br><span class="line"><span class="string">2   K1   K0  A2  B2   C1   D1</span></span><br><span class="line"><span class="string">3   K1   K0  A2  B2   C2   D2</span></span><br><span class="line"><span class="string">4   K2   K1  A3  B3  NaN  NaN</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h3><p>indicator=True会将合并的记录放在新的一列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>], <span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df1</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   col1 col_left</span></span><br><span class="line"><span class="string">0     0        a</span></span><br><span class="line"><span class="string">1     1        b</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">df2</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   col1  col_right</span></span><br><span class="line"><span class="string">0     1          2</span></span><br><span class="line"><span class="string">1     2          2</span></span><br><span class="line"><span class="string">2     2          2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据col1进行合并，并启用indicator=True，最后打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   col1 col_left  col_right      _merge</span></span><br><span class="line"><span class="string">0     0        a        NaN   left_only</span></span><br><span class="line"><span class="string">1     1        b        2.0        both</span></span><br><span class="line"><span class="string">2     2      NaN        2.0  right_only</span></span><br><span class="line"><span class="string">3     2      NaN        2.0  right_only</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 自定indicator column的名称，并打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="string">'indicator_column'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   col1 col_left  col_right indicator_column</span></span><br><span class="line"><span class="string">0     0        a        NaN        left_only</span></span><br><span class="line"><span class="string">1     1        b        2.0             both</span></span><br><span class="line"><span class="string">2     2      NaN        2.0       right_only</span></span><br><span class="line"><span class="string">3     2      NaN        2.0       right_only</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="依据index合并"><a href="#依据index合并" class="headerlink" title="依据index合并"></a>依据index合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>])</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                      <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>])</span><br><span class="line"></span><br><span class="line">left</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A   B</span></span><br><span class="line"><span class="string">K0  A0  B0</span></span><br><span class="line"><span class="string">K1  A1  B1</span></span><br><span class="line"><span class="string">K2  A2  B2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">right</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     C   D</span></span><br><span class="line"><span class="string">K0  C0  D0</span></span><br><span class="line"><span class="string">K2  C2  D2</span></span><br><span class="line"><span class="string">K3  C3  D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据左右资料集的index进行合并，how='outer',并打印出</span></span><br><span class="line">res = pd.merge(left, right, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>, how=<span class="string">'outer'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">      A    B    C    D</span></span><br><span class="line"><span class="string">K0   A0   B0   C0   D0</span></span><br><span class="line"><span class="string">K1   A1   B1  NaN  NaN</span></span><br><span class="line"><span class="string">K2   A2   B2   C2   D2</span></span><br><span class="line"><span class="string">K3  NaN  NaN   C3   D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据左右资料集的index进行合并，how='inner',并打印出</span></span><br><span class="line">res = pd.merge(left, right, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>, how=<span class="string">'inner'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A   B   C   D</span></span><br><span class="line"><span class="string">K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="string">K2  A2  B2  C2  D2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="解决overlapping的问题"><a href="#解决overlapping的问题" class="headerlink" title="解决overlapping的问题"></a>解决overlapping的问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">boys = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>], <span class="string">'age'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">girls = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K3'</span>], <span class="string">'age'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用suffixes解决overlapping的问题，分清楚age来自哪个DataFrame</span></span><br><span class="line">res = pd.merge(boys, girls, on=<span class="string">'k'</span>, suffixes=[<span class="string">'_boy'</span>, <span class="string">'_girl'</span>], how=<span class="string">'inner'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    k  age_boy  age_girl</span></span><br><span class="line"><span class="string">0  K0        1         4</span></span><br><span class="line"><span class="string">1  K0        1         5</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(boys, girls, on=<span class="string">'k'</span>, suffixes=[<span class="string">'_boy'</span>, <span class="string">'_girl'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">res</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    k  age_boy  age_girl</span></span><br><span class="line"><span class="string">0  K0      1.0       4.0</span></span><br><span class="line"><span class="string">1  K0      1.0       5.0</span></span><br><span class="line"><span class="string">2  K1      2.0       NaN</span></span><br><span class="line"><span class="string">3  K2      3.0       NaN</span></span><br><span class="line"><span class="string">4  K3      NaN       6.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="八、plot出图"><a href="#八、plot出图" class="headerlink" title="八、plot出图"></a>八、plot出图</h1><h3 id="创建一个Series"><a href="#创建一个Series" class="headerlink" title="创建一个Series"></a>创建一个Series</h3><p>这是一个线性的数据，我们随机生成1000个数据，Series 默认的 index 就是从0开始的整数，但是这里我显式赋值以便让大家看的更清楚</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机生成1000个数据</span></span><br><span class="line">data = pd.Series(np.random.randn(<span class="number">1000</span>),index=np.arange(<span class="number">1000</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为了方便观看效果, 我们累加这个数据</span></span><br><span class="line">data.cumsum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas 数据可以直接观看其可视化形式</span></span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>就这么简单，熟悉 matplotlib 的朋友知道如果需要plot一个数据，我们可以使用 plt.plot(x=, y=)，把x,y的数据作为参数存进去，但是data本来就是一个数据，所以我们可以直接plot。 生成的结果就是下图：<br><img alt="img2" data-src="/images/python/5.2.png" class="lazyload"></p><h3 id="Dataframe-可视化"><a href="#Dataframe-可视化" class="headerlink" title="Dataframe 可视化"></a>Dataframe 可视化</h3><p>我们生成一个1000*4 的DataFrame，并对他们累加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">1000</span>,<span class="number">4</span>),</span><br><span class="line">    index=np.arange(<span class="number">1000</span>),</span><br><span class="line">    columns=list(<span class="string">"ABCD"</span>)</span><br><span class="line">    )</span><br><span class="line">data.cumsum()</span><br><span class="line">data.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt="img3" data-src="/images/python/5.3.png" class="lazyload"><br>这个就是我们刚刚生成的4个column的数据，因为有4组数据，所以4组数据会分别plot出来。plot 可以指定很多参数，具体的用法大家可以自己查一下<a href="http://pandas.pydata.org/pandas-docs/version/0.18.1/visualization.html" target="_blank" rel="noopener">这里</a></p><p>除了plot，我经常会用到还有scatter，这个会显示散点图，首先给大家说一下在 pandas 中有多少种方法</p><ul><li>bar</li><li>hist</li><li>box</li><li>kde</li><li>area</li><li>scatter</li><li>hexbin<br>但是我们今天不会一一介绍，主要说一下 plot 和 scatter. 因为scatter只有x，y两个属性，我们我们就可以分别给x, y指定数据<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'B'</span>,color=<span class="string">'DarkBlue'</span>,label=<span class="string">'Class1'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>然后我们在可以再画一个在同一个ax上面，选择不一样的数据列，不同的 color 和 label</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将之下这个 data 画在上一个 ax 上面</span></span><br><span class="line">data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'C'</span>,color=<span class="string">'LightGreen'</span>,label=<span class="string">'Class2'</span>,ax=ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下面就是我plot出来的图片<br><img alt="img4" data-src="/images/python/5.4.png" class="lazyload"></p><p>本节参考自莫烦python，学习请点击：<a href="https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-04Numpy</title>
      <link href="/2019/07/14/python-04Numpy/"/>
      <url>/2019/07/14/python-04Numpy/</url>
      
        <content type="html"><![CDATA[<ul><li>ndarray：一种多维数组对象</li><li>通用函数：快速的元素级数组函数</li><li>利用数组进行数据处理</li><li>用于数组的文件输入输出</li><li>线性代数</li><li>伪随机数生成</li><li>示例：随机漫步</li></ul><a id="more"></a><p><a href="https://numpy.org/devdocs/reference/index.html" target="_blank" rel="noopener">NumPy</a>（Numerical Python的简称）是Python数值计算最重要的基础包。</p><p>NumPy的部分功能如下：</p><ul><li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li><li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li><li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li><li>线性代数、随机数生成以及傅里叶变换功能。</li><li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li></ul><p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。<br>这是因为：</p><ul><li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li><li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li></ul><p>numpy可以高效处理大数组的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">my_arr = np.arange(<span class="number">100000</span>)</span><br><span class="line">my_list = list(range(<span class="number">100000</span>))</span><br><span class="line"></span><br><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_arr2 = my_arr *<span class="number">2</span></span><br><span class="line"><span class="comment"># Wall time: 1 ms</span></span><br><span class="line"></span><br><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_list2 = my_list *<span class="number">2</span></span><br><span class="line"><span class="comment"># Wall time: 32.9 ms</span></span><br></pre></td></tr></table></figure><h1 id="一、NumPy的ndarray：一种多维数组对象"><a href="#一、NumPy的ndarray：一种多维数组对象" class="headerlink" title="一、NumPy的ndarray：一种多维数组对象"></a>一、NumPy的ndarray：一种多维数组对象</h1><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），是一个快速而灵活的大数据集容器。可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.5830263 , -0.39590117,  0.72400691],</span></span><br><span class="line"><span class="string">       [ 0.83895026, -0.1634468 , -1.55589942]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数学运算：</span></span><br><span class="line">data*<span class="number">10</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  5.83026299,  -3.95901173,   7.24006906],</span></span><br><span class="line"><span class="string">       [  8.38950264,  -1.63446803, -15.5589942 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">data+data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 2.47469633,  0.01421658,  0.21865621],</span></span><br><span class="line"><span class="string">       [ 3.72025764, -0.31933374, -0.8535659 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个<br>用于说明数组数据类型的对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data.shape <span class="comment"># (2,3)</span></span><br><span class="line"></span><br><span class="line">data.dtype <span class="comment"># dtype('float64')</span></span><br><span class="line"></span><br><span class="line">data.ndim <span class="comment"># 维度是2</span></span><br></pre></td></tr></table></figure><h3 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h3><p>创建数组最简单的办法就是使用<strong>array函数</strong>。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data1 = [<span class="number">3</span>,<span class="number">5.9</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1 <span class="comment"># array([3. , 5.9, 2. , 6. ])</span></span><br><span class="line"></span><br><span class="line">data2 = [[<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">29</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">16</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2 </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 3,  9,  2,  6],</span></span><br><span class="line"><span class="string">       [29,  4,  3, 16]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2.ndim <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">arr2.shape <span class="comment"># (2, 4)</span></span><br></pre></td></tr></table></figure><p>np.array会尝试为新建的这个数组推断出一个较为合适的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr2.dtype <span class="comment"># dtype('int32')</span></span><br></pre></td></tr></table></figure><p>除np.array之外，还有一些函数也可以新建数组。</p><ul><li><p>zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>) </span><br><span class="line"><span class="comment"># array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</span></span><br></pre></td></tr></table></figure></li><li><p>empty可以创建一个没有任何具体值的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li></ul><p>认为np.empty会返回全0数组的想法是不安全的，很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p><ul><li><p>arange是Python内置函数range的数组版。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[3, 3, 3, 3],</span></span><br><span class="line"><span class="string">       [3, 3, 3, 3]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>eye可以创建一个N*N的数组（对角线为1其余为0）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">6</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1., 0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 1., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 1., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 1., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0., 1., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0., 0., 1.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>full可以创建全部为指定值的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.full((<span class="number">2</span>,<span class="number">4</span>),<span class="number">3</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[3, 3, 3, 3],</span></span><br><span class="line"><span class="string">       [3, 3, 3, 3]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h3><p>使用dtype指定数组数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=np.float64)</span><br><span class="line">arr1.dtype <span class="comment"># dtype('float64')</span></span><br></pre></td></tr></table></figure><p>Numpy的数据类型：<br><img alt="img1" data-src="/images/python/4.1.png" class="lazyload"><br><img alt="img2" data-src="/images/python/4.2.png" class="lazyload"><br>可以通过ndarray的<strong>astype</strong>方法明确地将一个数组从一个dtype转换成另一个dtype：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype('int32')</span></span><br><span class="line"></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">float_arr.dtype <span class="comment"># dtype('float64')</span></span><br></pre></td></tr></table></figure><p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1.7</span>,<span class="number">20.6</span>,<span class="number">0.93</span>,<span class="number">4</span>])</span><br><span class="line">arr.astype(np.int32) <span class="comment"># array([ 1, 20,  0,  4])</span></span><br></pre></td></tr></table></figure><p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numeric_strings = np.array([<span class="string">'1.24'</span>,<span class="string">'6.99'</span>],dtype=np.string_)</span><br><span class="line">numeric_strings.astype(float) <span class="comment"># array([1.24, 6.99])</span></span><br></pre></td></tr></table></figure><p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。上面写的是float而不np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p><p>数组的dtype还有另一个属性，将一个数组类型转化成另一个数组的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int_array = np.arange(<span class="number">10</span>)</span><br><span class="line">xx = np.array([<span class="number">.33</span>,<span class="number">.24</span>,<span class="number">.5</span>])</span><br><span class="line">int_array.astype(xx.dtype)</span><br></pre></td></tr></table></figure><p>你还可以用简洁的类型代码来表示dtype：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">'u4'</span>)</span><br><span class="line">empty_uint32</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([         0, 1075314688,          0, 1075707904,          0,</span></span><br><span class="line"><span class="string">       1075838976,          0, 1072693248], dtype=uint32)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p></blockquote><h3 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h3><p>大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">arr * arr </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  1.,   4.,   9.],</span></span><br><span class="line"><span class="string">       [ 16.,  25.,  36.]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line">arr - arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line"><span class="number">1</span> / arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.    ,  0.5   ,  0.3333],</span></span><br><span class="line"><span class="string">       [ 0.25  ,  0.2   ,  0.1667]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line">arr ** <span class="number">0.5</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.    ,  1.4142,  1.7321],</span></span><br><span class="line"><span class="string">       [ 2.    ,  2.2361,  2.4495]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>大小相同的数组之间的比较会生成布尔值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([[<span class="number">0.</span>, <span class="number">4.</span>, <span class="number">1.</span>], [<span class="number">7.</span>, <span class="number">2.</span>, <span class="number">12.</span>]])</span><br><span class="line">arr2 &gt; arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[False,  True, False],</span></span><br><span class="line"><span class="string">       [ True, False,  True]], dtype=bool)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line">arr </span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span></span><br></pre></td></tr></table></figure><p>当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（广播）到整个选区。跟列表最重要的区别在于，<strong>数组切片是原始数组的视图</strong>。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。<br>作为例子，先创建一个arr的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice</span><br><span class="line"><span class="comment"># array([12, 12, 12])</span></span><br></pre></td></tr></table></figure><p>切片[ : ]会给数组中的所有值赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_slice[:] = <span class="number">64</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p></blockquote><p>在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">arr2d[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([7, 8, 9])</span></span><br></pre></td></tr></table></figure><p>访问单个元素，下面两种方式是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>] <span class="comment"># 3</span></span><br><span class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>] <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])</span></span><br><span class="line">arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># array([ 1,  2,  3,  4, 64])</span></span><br></pre></td></tr></table></figure><p>对于之前的二维数组arr2d，其切片方式稍显不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arr2d </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [4, 5, 6],</span></span><br><span class="line"><span class="string">       [7, 8, 9]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [4, 5, 6]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2, 3],</span></span><br><span class="line"><span class="string">       [5, 6]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [4],</span></span><br><span class="line"><span class="string">       [7]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.0072, -1.2962,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864, -2.0016, -0.3718],</span></span><br><span class="line"><span class="string">       [ 1.669 , -0.4386, -0.5397,  0.477 ],</span></span><br><span class="line"><span class="string">       [ 3.2489, -1.0212, -0.5771,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [-0.7135, -0.8312, -2.3702, -1.8608]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>我们想要选出对应于名字”Bob”的所有行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names == <span class="string">'Bob'</span></span><br><span class="line"><span class="comment"># array([ True, False, False,  True, False, False, False], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>这个布尔型数组可用于数组索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.669 , -0.4386, -0.5397,  0.477 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>下面的例子，我选取了<code>names == &#39;Bob&#39;</code>的行，并索引了列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [-0.5397,  0.477 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>~操作符用来反转条件很好用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cond = names == <span class="string">'Bob'</span></span><br><span class="line">data[~cond]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.0072, -1.2962,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864, -2.0016, -0.3718],</span></span><br><span class="line"><span class="string">       [ 3.2489, -1.0212, -0.5771,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [-0.7135, -0.8312, -2.3702, -1.8608]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)</span><br><span class="line">mask</span><br><span class="line"><span class="comment"># array([ True, False,  True,  True,  True, False, False], dtype=bool)</span></span><br></pre></td></tr></table></figure><blockquote><p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p></blockquote><p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.0072,  0.    ,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864,  0.    ,  0.    ],</span></span><br><span class="line"><span class="string">       [ 1.669 ,  0.    ,  0.    ,  0.477 ],</span></span><br><span class="line"><span class="string">       [ 3.2489,  0.    ,  0.    ,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    ,  0.    ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引指的是利用整数数组进行索引。假设我们有一个8×4数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">arr[i] = i</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 1.,  1.,  1.,  1.],</span></span><br><span class="line"><span class="string">       [ 2.,  2.,  2.,  2.],</span></span><br><span class="line"><span class="string">       [ 3.,  3.,  3.,  3.],</span></span><br><span class="line"><span class="string">       [ 4.,  4.,  4.,  4.],</span></span><br><span class="line"><span class="string">       [ 5.,  5.,  5.,  5.],</span></span><br><span class="line"><span class="string">       [ 6.,  6.,  6.,  6.],</span></span><br><span class="line"><span class="string">       [ 7.,  7.,  7.,  7.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]] </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 4.,  4.,  4.,  4.],</span></span><br><span class="line"><span class="string">       [ 3.,  3.,  3.,  3.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 6.,  6.,  6.,  6.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">       [12, 13, 14, 15],</span></span><br><span class="line"><span class="string">       [16, 17, 18, 19],</span></span><br><span class="line"><span class="string">       [20, 21, 22, 23],</span></span><br><span class="line"><span class="string">       [24, 25, 26, 27],</span></span><br><span class="line"><span class="string">       [28, 29, 30, 31]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="comment"># array([ 4, 23, 29, 10])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 4,  7,  5,  6],</span></span><br><span class="line"><span class="string">       [20, 23, 21, 22],</span></span><br><span class="line"><span class="string">       [28, 31, 29, 30],</span></span><br><span class="line"><span class="string">       [ 8, 11,  9, 10]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p></blockquote><h3 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3,  4],</span></span><br><span class="line"><span class="string">       [ 5,  6,  7,  8,  9],</span></span><br><span class="line"><span class="string">       [10, 11, 12, 13, 14]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.T</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  5, 10],</span></span><br><span class="line"><span class="string">       [ 1,  6, 11],</span></span><br><span class="line"><span class="string">       [ 2,  7, 12],</span></span><br><span class="line"><span class="string">       [ 3,  8, 13],</span></span><br><span class="line"><span class="string">       [ 4,  9, 14]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>利用np.dot计算矩阵内积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[-0.8608,  0.5601, -1.2659],</span></span><br><span class="line"><span class="string">       [ 0.1198, -1.0635,  0.3329],</span></span><br><span class="line"><span class="string">       [-2.3594, -0.1995, -1.542 ],</span></span><br><span class="line"><span class="string">       [-0.9707, -1.307 ,  0.2863],</span></span><br><span class="line"><span class="string">       [ 0.378 , -0.7539,  0.3313],</span></span><br><span class="line"><span class="string">       [ 1.3497,  0.0699,  0.2467]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">np.dot(arr.T, arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 9.2291,  0.9394,  4.948 ],</span></span><br><span class="line"><span class="string">       [ 0.9394,  3.7662, -1.3622],</span></span><br><span class="line"><span class="string">       [ 4.948 , -1.3622,  4.3437]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 8,  9, 10, 11]],</span></span><br><span class="line"><span class="string">       [[ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。<br>ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  4],</span></span><br><span class="line"><span class="string">        [ 1,  5],</span></span><br><span class="line"><span class="string">        [ 2,  6],</span></span><br><span class="line"><span class="string">        [ 3,  7]],</span></span><br><span class="line"><span class="string">       [[ 8, 12],</span></span><br><span class="line"><span class="string">        [ 9, 13],</span></span><br><span class="line"><span class="string">        [10, 14],</span></span><br><span class="line"><span class="string">        [11, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p><h1 id="二、通用函数：快速的元素级数组函数"><a href="#二、通用函数：快速的元素级数组函数" class="headerlink" title="二、通用函数：快速的元素级数组函数"></a>二、通用函数：快速的元素级数组函数</h1><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。<br>以下是一元（unary）ufunc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([ 0.    ,  1.    ,  1.4142,  1.7321,  2.    , </span></span><br><span class="line"><span class="string">2.2361,  2.4495,  2.6458,  2.8284,  3.    ])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">np.exp(arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([    1.    ,     2.7183,     7.3891,    20.0855,    54.5982,</span></span><br><span class="line"><span class="string">         148.4132,   403.4288,  1096.6332,  2980.958 ,  8103.0839])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">8</span>)</span><br><span class="line">y = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="comment"># array([-0.0119,  1.0048,  1.3272, -0.9193, -1.5491,  0.0222,  0.7584, -0.6605])</span></span><br><span class="line"></span><br><span class="line">y</span><br><span class="line"><span class="comment"># array([ 0.8626, -0.01  ,  0.05  ,  0.6702,  0.853 , -0.9559, -0.0235,  -2.3042])</span></span><br><span class="line">       </span><br><span class="line">np.maximum(x, y)</span><br><span class="line"><span class="comment"># array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,  -0.6605])</span></span><br></pre></td></tr></table></figure><p>有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])</span></span><br><span class="line"></span><br><span class="line">remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">remainder</span><br><span class="line"><span class="comment"># array([-0.2623, -0.0915, -0.663 ,  0.3731, 0.6182,  0.45  ,  0.0077])</span></span><br><span class="line"></span><br><span class="line">whole_part</span><br><span class="line"><span class="comment"># array([-3., -6., -6.,  5.,  3.,  3.,  5.])</span></span><br></pre></td></tr></table></figure><p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="comment"># array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr)</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr, arr)</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br></pre></td></tr></table></figure><p>下面两个表分别列出了一些一元和二元ufunc。<br><img alt="img3-1" data-src="/images/python/4.3.png" class="lazyload"><br><img alt="img3-2" data-src="/images/python/4.3.2.png" class="lazyload"><br><img alt="img4" data-src="/images/python/4.4.png" class="lazyload"></p><h1 id="三、利用数组进行数据处理"><a href="#三、利用数组进行数据处理" class="headerlink" title="三、利用数组进行数据处理"></a>三、利用数组进行数据处理</h1><p>假设我们想要在一组值（网格型）上计算函数sqrt(x^2+y^2)。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line">xs, ys = np.meshgrid(points, points)</span><br><span class="line">ys</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],</span></span><br><span class="line"><span class="string">       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],</span></span><br><span class="line"><span class="string">       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],</span></span><br><span class="line"><span class="string">       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],</span></span><br><span class="line"><span class="string">       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">z</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 7.0711,  7.064 ,  7.0569, ...,  7.0499,  7.0569,  7.064 ],</span></span><br><span class="line"><span class="string">       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569],</span></span><br><span class="line"><span class="string">       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428, 7.0499],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [ 7.0499,  7.0428,  7.0357, ...,  7.0286,  7.0357,  7.0428],</span></span><br><span class="line"><span class="string">       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428,  7.0499],</span></span><br><span class="line"><span class="string">       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>用matplotlib创建了这个二维数组的可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line"><span class="comment"># &lt;matplotlib.colorbar.Colorbar at 0x7f715e3fa630&gt;</span></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</span><br><span class="line"><span class="comment"># &lt;matplotlib.text.Text at 0x7f715d2de748&gt;</span></span><br></pre></td></tr></table></figure><p><img alt="img5" data-src="/images/python/4.5.png" class="lazyload"></p><h3 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h3><p>假设我们有一个布尔数组和两个值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">   .....:           <span class="keyword">for</span> x, y, c <span class="keyword">in</span> zip(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment"># [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]</span></span><br></pre></td></tr></table></figure><p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁，numpy.where函数是三元表达式x if condition else y的矢量化版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure><p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。</p><p>假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-0.5031, -0.6223, -0.9212, -0.7262],</span></span><br><span class="line"><span class="string">       [ 0.2229,  0.0513, -1.1577,  0.8167],</span></span><br><span class="line"><span class="string">       [ 0.4336,  1.0107,  1.8249, -0.9975],</span></span><br><span class="line"><span class="string">       [ 0.8506, -0.1316,  0.9124,  0.1882]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-2, -2, -2, -2],</span></span><br><span class="line"><span class="string">       [ 2,  2, -2,  2],</span></span><br><span class="line"><span class="string">       [ 2,  2,  2, -2],</span></span><br><span class="line"><span class="string">       [ 2, -2,  2,  2]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>传递给where的数组大小可以不相等，甚至可以是标量值。</p></blockquote><h3 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h3><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">arr.mean()</span><br><span class="line"><span class="comment"># 0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">np.mean(arr)</span><br><span class="line"><span class="comment"># 0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">arr.sum()</span><br><span class="line"><span class="comment"># 3.9214102239996507</span></span><br><span class="line"></span><br><span class="line">arr.mean(axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([ 1.022 ,  0.1875, -0.502 , -0.0881,  0.3611])</span></span><br><span class="line"></span><br><span class="line">arr.sum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># array([ 3.1693, -2.6345,  2.2381,  1.1486])</span></span><br></pre></td></tr></table></figure><p>arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p><p>累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 列累加</span></span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 0,  1,  2],</span></span><br><span class="line"><span class="string">       [ 3,  5,  7],</span></span><br><span class="line"><span class="string">       [ 9, 12, 15]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 行累加</span></span><br><span class="line">arr.cumsum(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 0,  1,  3],</span></span><br><span class="line"><span class="string">       [ 3,  7,  12],</span></span><br><span class="line"><span class="string">       [ 6, 13, 21]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 行累乘</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[  0,   0,   0],</span></span><br><span class="line"><span class="string">       [  3,  12,  60],</span></span><br><span class="line"><span class="string">       [  6,  42, 336]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>下表列出了全部的基本数组统计方法。<br><img alt="img6-1" data-src="/images/python/4.6.1.png" class="lazyload"><br><img alt="img6-2" data-src="/images/python/4.6.2.png" class="lazyload"></p><h3 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h3><p>sum经常被用来对布尔型数组中的True值计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">(arr &gt; <span class="number">0</span>).sum() <span class="comment"># Number of positive values</span></span><br><span class="line"><span class="comment"># 42</span></span><br></pre></td></tr></table></figure><p>any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">bools.any() <span class="comment"># True</span></span><br><span class="line">bools.all() <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0.6095, -0.4938,  1.24  , -0.1357,  1.43  , -0.8469])</span></span><br><span class="line"></span><br><span class="line">arr.sort()<span class="comment"># 多维数组也可以</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([-0.8469, -0.4938, -0.1357,  0.6095,  1.24  ,  1.43  ])</span></span><br></pre></td></tr></table></figure><p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.6033,  1.2636, -0.2555],</span></span><br><span class="line"><span class="string">       [-0.4457,  0.4684, -0.9616],</span></span><br><span class="line"><span class="string">       [-1.8245,  0.6254,  1.0229],</span></span><br><span class="line"><span class="string">       [ 1.1074,  0.0909, -0.3501],</span></span><br><span class="line"><span class="string">       [ 0.218 , -0.8948, -1.7415]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="number">1</span>) <span class="comment"># 按行排列</span></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-0.2555,  0.6033,  1.2636],</span></span><br><span class="line"><span class="string">       [-0.9616, -0.4457,  0.4684],</span></span><br><span class="line"><span class="string">       [-1.8245,  0.6254,  1.0229],</span></span><br><span class="line"><span class="string">       [-0.3501,  0.0909,  1.1074],</span></span><br><span class="line"><span class="string">       [-1.7415, -0.8948,  0.218 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h3><p>最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line"></span><br><span class="line">np.unique(names)</span><br><span class="line"><span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')</span></span><br><span class="line"></span><br><span class="line">ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">np.unique(ints)</span><br><span class="line"><span class="comment"># array([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>拿跟np.unique等价的纯Python代码来对比一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(set(names))</span><br><span class="line"><span class="comment"># ['Bob', 'Joe', 'Will']</span></span><br></pre></td></tr></table></figure><p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>np.intersect1d计算x,y的公共元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.intersect1d([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># array([2, 4])</span></span><br></pre></td></tr></table></figure><p><img alt="img7" data-src="/images/python/4.7.png" class="lazyload"></p><h1 id="四、用于数组的文件输入输出"><a href="#四、用于数组的文件输入输出" class="headerlink" title="四、用于数组的文件输入输出"></a>四、用于数组的文件输入输出</h1><p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr)</span><br></pre></td></tr></table></figure><p>通过np.load读取磁盘上的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure><p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line"></span><br><span class="line">arch[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p>如果要将数据压缩，可以使用numpy.savez_compressed：</p><figure class="highlight python"><figcaption><span>np.savez_compressed('arrays_compressed.npz', a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment"># 五、线性代数</span></span><br><span class="line">NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</span><br><span class="line">```python</span><br><span class="line">x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line">y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [<span class="number">-1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">x.dot(y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  28.,   64.],</span></span><br><span class="line"><span class="string">       [  67.,  181.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>x.dot(y)等价于np.dot(x, y)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.dot(x, y)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[  28.,   64.],</span></span><br><span class="line"><span class="string">       [  67.,  181.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>@符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x @ np.ones(<span class="number">3</span>) <span class="comment"># array([  6.,  15.])</span></span><br></pre></td></tr></table></figure><p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line">X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">mat = X.T.dot(X)</span><br><span class="line">inv(mat)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  933.1189,   871.8258, -1417.6902, -1460.4005,  1782.1391],</span></span><br><span class="line"><span class="string">       [  871.8258,   815.3929, -1325.9965, -1365.9242,  1666.9347],</span></span><br><span class="line"><span class="string">       [-1417.6902, -1325.9965,  2158.4424,  2222.0191, -2711.6822],</span></span><br><span class="line"><span class="string">       [-1460.4005, -1365.9242,  2222.0191,  2289.0575, -2793.422 ],</span></span><br><span class="line"><span class="string">       [ 1782.1391,  1666.9347, -2711.6822, -2793.422 ,  3409.5128]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">mat.dot(inv(mat))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.,  0., -0., -0., -0.],</span></span><br><span class="line"><span class="string">       [-0.,  1.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  1.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [-0.,  0.,  0.,  1., -0.],</span></span><br><span class="line"><span class="string">       [-0.,  0.,  0.,  0.,  1.]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">q, r = qr(mat)</span><br><span class="line">r</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-1.6914,  4.38  ,  0.1757,  0.4075, -0.7838],</span></span><br><span class="line"><span class="string">       [ 0.    , -2.6436,  0.1939, -3.072 , -1.0702],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    , -0.8138,  1.5414,  0.6155],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    , -2.6445, -2.1669],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    ,  0.    ,  0.0002]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>下表列出了一些最常用的线性代数函数。<br><img alt="img8" data-src="/images/python/4.8.png" class="lazyload"></p><h1 id="六、伪随机数生成"><a href="#六、伪随机数生成" class="headerlink" title="六、伪随机数生成"></a>六、伪随机数生成</h1><p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。</p><p>例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">samples</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.5732,  0.1933,  0.4429,  1.2796],</span></span><br><span class="line"><span class="string">       [ 0.575 ,  0.4339, -0.7658, -1.237 ],</span></span><br><span class="line"><span class="string">       [-0.5367,  1.8545, -0.92  , -0.1082],</span></span><br><span class="line"><span class="string">       [ 0.1525,  0.9435, -1.0953, -0.144 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">%timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># 1.77 s +- 126 ms per loop (mean +- std. dev. of 7 runs, 1 loop each)</span></span><br><span class="line"></span><br><span class="line">%timeit np.random.normal(size=N)</span><br><span class="line"><span class="comment"># 61.7 ms +- 1.32 ms per loop (mean +- std. dev. of 7 runs, 10 loops each)</span></span><br></pre></td></tr></table></figure><p>这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([ 0.4714, -1.191 ,  1.4327, -0.3127, -0.7206,  0.8872,  0.8596,</span></span><br><span class="line"><span class="string">       -0.6365,  0.0157, -2.2427])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>下表列出了numpy.random中的部分函数。<br><img alt="img9-1" data-src="/images/python/4.9.1.png" class="lazyload"><br><img alt="img9-2" data-src="/images/python/4.9.2.png" class="lazyload"></p><h1 id="七、示例：随机漫步"><a href="#七、示例：随机漫步" class="headerlink" title="七、示例：随机漫步"></a>七、示例：随机漫步</h1><p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">   .....: position = <span class="number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="number">1000</span></span><br><span class="line">   .....: <span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">   .....:     step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br></pre></td></tr></table></figure><p>下图根据前100个随机漫步值生成的折线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(walk[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure><p><img alt="img10" data-src="/images/python/4.10.png" class="lazyload"><br>我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">walk = steps.cumsum()</span><br><span class="line">walk.min() <span class="comment"># -3</span></span><br><span class="line">walk.max() <span class="comment"># 31</span></span><br></pre></td></tr></table></figure><p>假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(np.abs(walk) &gt;= <span class="number">10</span>).argmax() <span class="comment"># 37</span></span><br></pre></td></tr></table></figure><h3 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h3><p>如果你希望模拟多个随机漫步过程（比如5000个），只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=(nwalks,nsteps))</span><br><span class="line">steps = np.where(draws&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  1,   0,   1, ...,   8,   7,   8],</span></span><br><span class="line"><span class="string">       [  1,   0,  -1, ...,  34,  33,  32],</span></span><br><span class="line"><span class="string">       [  1,   0,  -1, ...,   4,   5,   4],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [  1,   2,   1, ...,  24,  25,  26],</span></span><br><span class="line"><span class="string">       [  1,   2,   3, ...,  14,  13,  14],</span></span><br><span class="line"><span class="string">       [ -1,  -2,  -3, ..., -24, -23, -22]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">walk.max() <span class="comment"># 138</span></span><br><span class="line">walk.min() <span class="comment"># -133</span></span><br></pre></td></tr></table></figure><p>计算30或－30的最小穿越时间，不是5000个过程都到达了30，用any方法来对此进行检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hits30=(np.abs(walk)&gt;=<span class="number">30</span>).any(<span class="number">1</span>)</span><br><span class="line">hits30.sum() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line"><span class="comment"># 3410</span></span><br></pre></td></tr></table></figure><p>这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crossing_times = (np.abs(walk[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean() <span class="comment"># 498.88973607038122</span></span><br></pre></td></tr></table></figure><p>用其他分布方式得到漫步数据，比如normal用于生成指定均值和标准差的正态分布数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steps = np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">0.25</span>,size=(nwalks,nsteps))</span><br><span class="line">walk = steps.cumsum(<span class="number">1</span>)</span><br><span class="line">hits30=(np.abs(walk)&gt;=<span class="number">30</span>).any(<span class="number">1</span>)</span><br><span class="line">crossing_times = (np.abs(walk[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean() <span class="comment"># 999.0</span></span><br></pre></td></tr></table></figure><p>本节参考自《利用python进行数据分析》第四章，阅读链接：<a href="https://wizardforcel.gitbooks.io/pyda-2e/content/4.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/pyda-2e/content/4.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-03高级特性</title>
      <link href="/2019/07/11/python-03%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2019/07/11/python-03%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<ul><li>切片</li><li>迭代</li><li>列表生成式</li><li>生成器</li><li>迭代器</li></ul><a id="more"></a><p>这一节介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。</p><h1 id="一、切片"><a href="#一、切片" class="headerlink" title="一、切片"></a>一、切片</h1><p>一个list如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br></pre></td></tr></table></figure><p>取前3个元素，应该怎么做？</p><p>笨办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>或者取前N个元素，也就是索引为0-(N-1)的元素，可以用循环。</p><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了<strong>切片（Slice）</strong>操作符，能大大简化这种操作。</p><p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p><p>如果第一个索引是0，还可以省略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[&apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; L[-2:-1]</span><br><span class="line">[&apos;Bob&apos;]</span><br></pre></td></tr></table></figure><p>切片操作十分有用。我们先创建一个0-99的数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = list(range(100))</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>可以通过切片轻松取出某一段数列。比如后10个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure><p>前10个数，每两个取一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>甚至什么都不写，只写[:]就可以原样复制一个list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</span><br><span class="line">(0, 1, 2)</span><br></pre></td></tr></table></figure><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def trim(s):</span><br><span class="line">if n == &apos;&apos;</span><br><span class="line">    return s</span><br><span class="line">    else:</span><br><span class="line">        n = 0</span><br><span class="line">    m = len(s)    </span><br><span class="line">        while s[n] == &apos; &apos; and n &lt; m-1:</span><br><span class="line">            n += 1        </span><br><span class="line">        while s[m-1] == &apos; &apos; and m &gt; n:</span><br><span class="line">            m -= 1</span><br><span class="line">        return s[n:m]</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def trim(s):</span><br><span class="line">    if len(s) != 0:    </span><br><span class="line">        while s[:1] == &apos; &apos;:</span><br><span class="line">            s = s[1:]</span><br><span class="line">        while s[-1:] == &apos; &apos;:</span><br><span class="line">            s = s[:-1]</span><br><span class="line">    return s</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"># 测试:</span><br><span class="line">if trim(&apos;hello  &apos;) != &apos;hello&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif trim(&apos;  hello&apos;) != &apos;hello&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif trim(&apos;  hello  &apos;) != &apos;hello&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif trim(&apos;  hello  world  &apos;) != &apos;hello  world&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif trim(&apos;&apos;) != &apos;&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif trim(&apos;    &apos;) != &apos;&apos;:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;测试成功!&apos;)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。</p><h1 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h1><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，迭代是通过for … in来完成的。Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。比如dict就可以迭代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">print(key)</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure><ul><li>默认情况下，dict迭代的是key;</li><li>如果要迭代value，可以用for value in d.values();</li><li>如果要同时迭代key和value，可以用for k, v in d.items()。</li></ul><p>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的<strong>enumerate</strong>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure><p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     print(x, y)</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>请使用迭代查找一个list中最小和最大值，并返回一个tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def findMinAndMax(L):</span><br><span class="line">    if L == []:</span><br><span class="line">        return(None,None)</span><br><span class="line">    else:</span><br><span class="line">        return(min(L),max(L))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">if findMinAndMax([]) != (None, None):</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif findMinAndMax([7]) != (7, 7):</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif findMinAndMax([7, 1]) != (1, 7):</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9):</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;测试成功!&apos;)</span><br></pre></td></tr></table></figure><h1 id="三、列表生成式"><a href="#三、列表生成式" class="headerlink" title="三、列表生成式"></a>三、列表生成式</h1><p>列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式。举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(1,11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录</span><br><span class="line">[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</span><br></pre></td></tr></table></figure><p>列表生成式也可以使用两个变量来生成list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</span><br></pre></td></tr></table></figure><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;listcomp&gt;</span><br><span class="line">AttributeError: &apos;int&apos; object has no attribute &apos;lower&apos;</span><br></pre></td></tr></table></figure><p>使用内建的isinstance函数可以判断一个变量是不是字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; y = 123</span><br><span class="line">&gt;&gt;&gt; isinstance(x, str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(y, str)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>请修改列表生成式，通过添加if语句保证列表生成式能正确地执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L1 = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]</span><br><span class="line">L2 = [s.lower() for s in L1 if isinstance(s, str)]</span><br><span class="line"></span><br><span class="line"># 测试:</span><br><span class="line">print(L2)</span><br><span class="line">if L2 == [&apos;hello&apos;, &apos;world&apos;, &apos;apple&apos;]:</span><br><span class="line">    print(&apos;测试通过!&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br><span class="line"># 测试通过!</span><br></pre></td></tr></table></figure><h1 id="四、生成器"><a href="#四、生成器" class="headerlink" title="四、生成器"></a>四、生成器</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong>一边循环一边计算的机制</strong>，称为生成器：generator。</p><p>创建一个generator有很多种方法。</p><ul><li>第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们怎么打印出generator的每一个元素呢？如果要一个一个打印出来，可以通过<strong>next()函数</strong>获得generator的下一个返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>但上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p><ul><li>第二种方法是使用关键字yield</li></ul><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure><p>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p><p>也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure><p>这就是定义generator的另一种方法。如果一个函数定义中包含<strong>yield</strong>关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = fib(6)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;generator object fib at 0x104feaaa0&gt;</span><br></pre></td></tr></table></figure><p>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&apos;step 1&apos;)</span><br><span class="line">    yield(1)</span><br><span class="line">    print(&apos;step 2&apos;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&apos;step 3&apos;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; o = odd()</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</p><p>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p><p>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in fib(6):</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = fib(6)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     try:</span><br><span class="line">...         x = next(g)</span><br><span class="line">...         print(&apos;g:&apos;, x)</span><br><span class="line">...     except StopIteration as e:</span><br><span class="line">...         print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">...         break</span><br><span class="line">...</span><br><span class="line">g: 1</span><br><span class="line">g: 1</span><br><span class="line">g: 2</span><br><span class="line">g: 3</span><br><span class="line">g: 5</span><br><span class="line">g: 8</span><br><span class="line">Generator return value: done</span><br></pre></td></tr></table></figure><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p>杨辉三角定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        1   1</span><br><span class="line">       / \ / \</span><br><span class="line">      1   2   1</span><br><span class="line">     / \ / \ / \</span><br><span class="line">    1   3   3   1</span><br><span class="line">   / \ / \ / \ / \</span><br><span class="line">  1   4   6   4   1</span><br><span class="line"> / \ / \ / \ / \ / \</span><br><span class="line">1   5   10  10  5   1</span><br></pre></td></tr></table></figure><p>把每一行看做一个list，试写一个generator，不断输出下一行的list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">def triangles():</span><br><span class="line">    L = [1]</span><br><span class="line">    yield L</span><br><span class="line">    while True:</span><br><span class="line">        L=[1]+[L[x]+L[x+1] for x in range(len(L)-1)]+[1]</span><br><span class="line">        yield L</span><br><span class="line"></span><br><span class="line"># 期待输出:</span><br><span class="line"># [1]</span><br><span class="line"># [1, 1]</span><br><span class="line"># [1, 2, 1]</span><br><span class="line"># [1, 3, 3, 1]</span><br><span class="line"># [1, 4, 6, 4, 1]</span><br><span class="line"># [1, 5, 10, 10, 5, 1]</span><br><span class="line"># [1, 6, 15, 20, 15, 6, 1]</span><br><span class="line"># [1, 7, 21, 35, 35, 21, 7, 1]</span><br><span class="line"># [1, 8, 28, 56, 70, 56, 28, 8, 1]</span><br><span class="line"># [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</span><br><span class="line">n = 0</span><br><span class="line">results = []</span><br><span class="line">for t in triangles():</span><br><span class="line">    print(t)</span><br><span class="line">    results.append(t)</span><br><span class="line">    n = n + 1</span><br><span class="line">    if n == 10:</span><br><span class="line">        break</span><br><span class="line">    </span><br><span class="line">if results == [</span><br><span class="line">    [1],</span><br><span class="line">    [1, 1],</span><br><span class="line">    [1, 2, 1],</span><br><span class="line">    [1, 3, 3, 1],</span><br><span class="line">    [1, 4, 6, 4, 1],</span><br><span class="line">    [1, 5, 10, 10, 5, 1],</span><br><span class="line">    [1, 6, 15, 20, 15, 6, 1],</span><br><span class="line">    [1, 7, 21, 35, 35, 21, 7, 1],</span><br><span class="line">    [1, 8, 28, 56, 70, 56, 28, 8, 1],</span><br><span class="line">    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</span><br><span class="line">]:</span><br><span class="line">    print(&apos;测试通过!&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;测试失败!&apos;)</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。</p><p>要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。</p><p>请注意区分普通函数和generator函数，普通函数调用直接返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = abs(6)</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>generator函数的“调用”实际返回一个generator对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = fib(6)</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object fib at 0x1022ef948&gt;</span><br></pre></td></tr></table></figure><h1 id="五、迭代器"><a href="#五、迭代器" class="headerlink" title="五、迭代器"></a>五、迭代器</h1><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p><ol><li><p>集合数据类型，如list、tuple、dict、set、str等；</p></li><li><p>generator，包括生成器和带yield的generator function。</p></li></ol><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>生成器generator都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>你可能会问，为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>凡是可作用于for循环的对象都是Iterable类型；</p><p>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p><p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br><span class="line">实际上完全等价于：</span><br><span class="line"></span><br><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>本节参考自廖雪峰老师的python教程，链接是：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-02函数</title>
      <link href="/2019/05/26/python-02%E5%87%BD%E6%95%B0/"/>
      <url>/2019/05/26/python-02%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>调用函数</li><li>定义函数</li><li>函数的参数</li><li>递归函数</li></ul><a id="more"></a><h1 id="一、调用函数"><a href="#一、调用函数" class="headerlink" title="一、调用函数"></a>一、调用函数</h1><p>Python内置了很多有用的函数，可以直接调用。<br><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a><br>比如求绝对值的函数abs，只有一个参数，可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">help(abs)</span><br><span class="line">Help on built-in function abs in module builtins:</span><br><span class="line"></span><br><span class="line">abs(x, /)</span><br><span class="line">    Return the absolute value of the argument.</span><br></pre></td></tr></table></figure><p>调用abs函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs(-20) # 20</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int(&apos;123&apos;) # 123</span><br><span class="line">int(12.34) # 12</span><br><span class="line">bool(&apos;&apos;) # False</span><br></pre></td></tr></table></figure><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = abs # 变量a指向abs函数</span><br><span class="line">a(-1) # 所以也可以通过a调用abs函数,返回1</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n1 = 255</span><br><span class="line">hex(n1) # &apos;0xff&apos;</span><br></pre></td></tr></table></figure><h1 id="二、定义函数"><a href="#二、定义函数" class="headerlink" title="二、定义函数"></a>二、定义函数</h1><p>以自定义一个求绝对值的my_abs函数为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br><span class="line">print(my_abs(-99)) # 99</span><br></pre></td></tr></table></figure><p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from abstest import my_abs   </span><br><span class="line">my_abs(-9) # 9</span><br></pre></td></tr></table></figure><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p><p>pass还可以用在其他语句里，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>缺少了pass，代码运行就会有语法错误。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: my_abs() takes 1 positional argument but 2 were given</span><br></pre></td></tr></table></figure><p>但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br><span class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &apos;str&apos;</span><br></pre></td></tr></table></figure><p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p><p>修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure><p>然后，我们就可以同时获得返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">print(x, y) # 151.96152422706632 70.0</span><br></pre></td></tr></table></figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">print(r) # (151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure><p>返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>定义函数时，需要确定函数名和参数个数；</p><p>如果有必要，可以先对参数的数据类型做检查；</p><p>函数体内部可以用return随时返回函数结果；</p><p>函数执行完毕也没有return语句时，自动return None。</p><p>函数可以同时返回多个值，但其实就是一个tuple。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的两个解。<br>提示：使用一元二次方程的求根公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def quadratic(a, b, c):</span><br><span class="line">    x1 = (-b + math.sqrt(b*b-4*a*c))/(2*a)</span><br><span class="line">    x2 = (-b - math.sqrt(b*b-4*a*c))/(2*a)</span><br><span class="line">    return x1,x2</span><br><span class="line"></span><br><span class="line">x1, x2 = quadratic(1, 5, 6)</span><br><span class="line">print(x1, x2) # -2.0 -3.0</span><br><span class="line"># 测试:</span><br><span class="line">print(&apos;quadratic(2, 3, 1) =&apos;, quadratic(2, 3, 1)) # quadratic(2, 3, 1) = (-0.5, -1.0)</span><br><span class="line">print(&apos;quadratic(1, 3, -4) =&apos;, quadratic(1, 3, -4)) # quadratic(1, 3, -4) = (1.0, -4.0)</span><br><span class="line"></span><br><span class="line">if quadratic(2, 3, 1) != (-0.5, -1.0):</span><br><span class="line">    print(&apos;测试失败&apos;)</span><br><span class="line">elif quadratic(1, 3, -4) != (1.0, -4.0):</span><br><span class="line">    print(&apos;测试失败&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;测试成功&apos;) # 测试成功</span><br></pre></td></tr></table></figure><h1 id="三、函数的参数"><a href="#三、函数的参数" class="headerlink" title="三、函数的参数"></a>三、函数的参数</h1><p>除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>我们先写一个计算$x^2$的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def power(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><p>对于power(x)函数，参数x就是一个位置参数。</p><p>当我们调用power函数时，必须传入有且仅有的一个参数x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(5) # 25</span><br></pre></td></tr></table></figure><p>现在，如果我们要计算$x^3$怎么办？可以再定义一个power3函数，但是如果要计算$x^4$、$x^5$……怎么办？我们不可能定义无限多个函数。</p><p>可以把power(x)修改为power(x, n)，用来计算$x^n$：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line">power(5, 2) # 25</span><br></pre></td></tr></table></figure><p>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: power() missing 1 required positional argument: &apos;n&apos;</span><br></pre></td></tr></table></figure><p>Python的错误信息很明确：调用函数power()缺少了一个位置参数n。</p><p>这个时候，默认参数就排上用场了。由于我们经常计算$x^2$，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>这样，当我们调用power(5)时，相当于调用power(5, 2)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">power(5) # 25</span><br><span class="line">power(5, 2)  # 25</span><br></pre></td></tr></table></figure><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>使用默认参数有什么好处？最大的好处是能降低调用函数的难。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>我们以数学题为例子，给定一组数字a，b，c……，请计算$a^2 + b^2 + c^2 + ……$。</p><p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个<strong>list</strong>或<strong>tuple</strong>传进来，这样，函数可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc([1, 2, 3]) # 14</span><br><span class="line">calc((1, 3, 5, 7)) # 84</span><br></pre></td></tr></table></figure><p>我们把函数的参数改为可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>利用可变参数，调用函数的方式可以简化成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc(1, 2, 3) # 14</span><br><span class="line">calc(1, 3, 5, 7) # 84</span><br><span class="line">calc() # 0</span><br></pre></td></tr></table></figure><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。<br>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">calc(nums[0], nums[1], nums[2]) # 14</span><br></pre></td></tr></table></figure><p>这种写法太繁琐，Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">calc(*nums) # 14</span><br></pre></td></tr></table></figure><p><strong>*nums</strong>表示把nums这个list的所有元素作为可变参数传进去。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(&apos;Michael&apos;, 30) # name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以传入任意个数的关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><p>关键字参数有什么用？它可以扩展函数的功能。</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</span><br><span class="line"># name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><p>当然，上面复杂的调用可以用简化的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line"># name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>**extra</strong>表示把extra这个dict的所有key-value用关键字参数传入到函数的<strong>**kw</strong>参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p><p>仍以person()函数为例，我们希望检查是否有city和job参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    if &apos;city&apos; in kw:</span><br><span class="line">        # 有city参数</span><br><span class="line">        pass</span><br><span class="line">    if &apos;job&apos; in kw:</span><br><span class="line">        # 有job参数</span><br><span class="line">        pass</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure><p>但调用者仍可以传入不受限制的关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, addr=&apos;Chaoyang&apos;, zipcode=123456)</span><br><span class="line"># name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;addr&apos;: &apos;Chaoyang&apos;, &apos;zipcode&apos;: 123456&#125;</span><br></pre></td></tr></table></figure><p>如果要限制关键字参数的名字，就可以用<strong>命名关键字参数</strong>，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数(city, job)被视为命名关键字参数。</p><p>调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</span><br><span class="line"># Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() takes 2 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。<br>若改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(&apos;Jack&apos;, 24, city = &apos;Beijing&apos;, job = &apos;Engineer&apos;)</span><br><span class="line"># Jack 24 () Beijing Engineer</span><br></pre></td></tr></table></figure><p>则没错。<br>命名关键字参数可以有缺省值，从而简化调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line"># Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<em>作为特殊分隔符。如果缺少</em>，Python解释器将无法识别位置参数和命名关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, city, job):</span><br><span class="line">    # 缺少 *，city和job被视为位置参数</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<br>比如定义一个函数，包含上述若干种参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br></pre></td></tr></table></figure><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure><p>所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>接收一个或多个数并计算乘积：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def product(*numbers):</span><br><span class="line">    sum = 1</span><br><span class="line">    if len(numbers) == 0:</span><br><span class="line">        raise TypeError(&apos;参数不能为空, 否则没有意义!&apos;)</span><br><span class="line">    else:</span><br><span class="line">        for n in numbers:</span><br><span class="line">            sum = sum * n</span><br><span class="line">        return sum</span><br><span class="line">print(&apos;product(5) =&apos;, product(5))</span><br><span class="line">print(&apos;product(5, 6) =&apos;, product(5, 6))</span><br><span class="line">print(&apos;product(5, 6, 7) =&apos;, product(5, 6, 7))</span><br><span class="line">print(&apos;product(5, 6, 7, 9) =&apos;, product(5, 6, 7, 9))</span><br><span class="line">if product(5) != 5:</span><br><span class="line">    print(&apos;测试1失败!&apos;)</span><br><span class="line">elif product(5, 6) != 30:</span><br><span class="line">    print(&apos;测试2失败!&apos;)</span><br><span class="line">elif product(5, 6, 7) != 210:</span><br><span class="line">    print(&apos;测试3失败!&apos;)</span><br><span class="line">elif product(5, 6, 7, 9) != 1890:</span><br><span class="line">    print(&apos;测试4失败!&apos;)</span><br><span class="line">else:</span><br><span class="line">    try:</span><br><span class="line">        product()</span><br><span class="line">        print(&apos;测试5失败!&apos;)</span><br><span class="line">    except TypeError:</span><br><span class="line">        print(&apos;测试6成功!&apos;)</span><br><span class="line">product()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">product(5) = 5</span><br><span class="line">product(5, 6) = 30</span><br><span class="line">product(5, 6, 7) = 210</span><br><span class="line">product(5, 6, 7, 9) = 1890</span><br><span class="line">测试6成功!</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p>*args是可变参数，args接收的是一个tuple；</p><p>**kw是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过<em>args传入：func(</em>(1, 2, 3))；</p><p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<strong>kw传入：func(</strong>{‘a’: 1, ‘b’: 2})。</p><p>使用<em>args和*</em>kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。</p><h1 id="四、递归函数"><a href="#四、递归函数" class="headerlink" title="四、递归函数"></a>四、递归函数</h1><p>如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>举个例子，我们来计算阶乘$n! = 1 x 2 x 3 x … x n$，用函数fact(n)表示，可以看出：</p><p>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n</p><p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p><p>于是，fact(n)用递归的方式写出来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br></pre></td></tr></table></figure><p>上面就是一个递归函数。可以试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure><p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===&gt; fact(5)</span><br><span class="line">===&gt; 5 * fact(4)</span><br><span class="line">===&gt; 5 * (4 * fact(3))</span><br><span class="line">===&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">===&gt; 5 * (4 * (3 * 2))</span><br><span class="line">===&gt; 5 * (4 * 6)</span><br><span class="line">===&gt; 5 * 24</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure><p>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</span><br><span class="line">  ...</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</span><br><span class="line">RuntimeError: maximum recursion depth exceeded in comparison</span><br></pre></td></tr></table></figure><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。<br>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    return fact_iter(n, 1)</span><br><span class="line"></span><br><span class="line">def fact_iter(num, product):</span><br><span class="line">    if num == 1:</span><br><span class="line">        return product</span><br><span class="line">    return fact_iter(num - 1, num * product)</span><br></pre></td></tr></table></figure><p>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。</p><p>fact(5)对应的fact_iter(5, 1)的调用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">===&gt; fact_iter(5, 1)</span><br><span class="line">===&gt; fact_iter(4, 5)</span><br><span class="line">===&gt; fact_iter(3, 20)</span><br><span class="line">===&gt; fact_iter(2, 60)</span><br><span class="line">===&gt; fact_iter(1, 120)</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p>汉诺塔的移动可以用递归函数非常简单地实现。</p><p>编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def move(n, a, b, c):</span><br><span class="line">    if n == 1:</span><br><span class="line">        print(a,&apos;--&gt;&apos;,c)</span><br><span class="line">    else:</span><br><span class="line">        # 先将a柱子上的（前）N-1个圆盘借助c移动到柱子b上；</span><br><span class="line">        move(n-1,a, c, b)</span><br><span class="line">        # 再把a上最后的大圆盘挪动到c上</span><br><span class="line">        move(1,a, b, c)</span><br><span class="line">        # 最后把b上的n-1个圆盘挪动到c上</span><br><span class="line">        move(n-1,b, a, c)</span><br><span class="line">move(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># A --&gt; C</span><br><span class="line"># A --&gt; B</span><br><span class="line"># C --&gt; B</span><br><span class="line"># A --&gt; C</span><br><span class="line"># B --&gt; A</span><br><span class="line"># B --&gt; C</span><br><span class="line"># A --&gt; C</span><br></pre></td></tr></table></figure><p>本节参考自廖雪峰老师的python教程，链接是：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017105145133280" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017105145133280</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-01基础</title>
      <link href="/2019/05/24/python-01%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/24/python-01%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul><li>数据类型和变量</li><li>字符串和编码</li><li>list和tuple</li><li>条件判断</li><li>循环</li><li>dict和set</li></ul><a id="more"></a><h1 id="一、数据类型和变量"><a href="#一、数据类型和变量" class="headerlink" title="一、数据类型和变量"></a>一、数据类型和变量</h1><p>在Python中，能够直接处理的数据类型有以下几种：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。<br>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数。对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。<br>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'I\'m \"OK\"!'</span>) <span class="comment"># I'm "OK"!</span></span><br></pre></td></tr></table></figure><p>\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\\\n\\'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>为了简化，Python还允许用r’’表示’’内部的字符串默认不转义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\\\t\\'</span>) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">\\</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(<span class="string">r'\\\t\\'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">\\\t\\</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>Python允许用’’’…’’’的格式表示多行内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'''line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3'''</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>一个布尔值只有True、False两种值，要么是True，要么是False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>布尔值可以用and、or和not运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="comment"># True</span></span><br><span class="line"><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="comment"># True</span></span><br><span class="line"><span class="literal">False</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="comment"># False</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span> &gt; <span class="number">3</span> <span class="comment"># True</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">True</span> <span class="comment"># False</span></span><br><span class="line"><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">2</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 变量a是一个整数</span></span><br></pre></td></tr></table></figure><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span> <span class="comment"># a是整数</span></span><br><span class="line">print(a) <span class="comment"># 123</span></span><br><span class="line">a = <span class="string">'ABC'</span> <span class="comment"># a变为字符串</span></span><br><span class="line">print(a) <span class="comment"># ABC</span></span><br></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">123</span>; // a是整数类型变量</span><br><span class="line">a = <span class="string">"ABC"</span>; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure><p>理解变量在计算机内存中的表示也非常重要。当我们写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'ABC'</span></span><br></pre></td></tr></table></figure><p>时，Python解释器干了两件事情：</p><ul><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ul><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'ABC'</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">'XYZ'</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>1.执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’;</p><p>2.执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’;</p><p>3.执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改。</p><p>所以，最后打印变量b的结果自然是’ABC’了。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14159265359</span></span><br></pre></td></tr></table></figure><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> / <span class="number">3</span> <span class="comment"># 3.3333333333333335</span></span><br></pre></td></tr></table></figure><p>/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> / <span class="number">3</span> <span class="comment"># 3.0</span></span><br></pre></td></tr></table></figure><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> // <span class="number">3</span> <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>整数的地板除//永远是整数，即使除不尽。</p><p>Python还提供一个余数运算，可以得到两个整数相除的余数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> % <span class="number">3</span> <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>请打印出以下变量的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">123</span></span><br><span class="line">f = <span class="number">456.789</span></span><br><span class="line">s1 = <span class="string">'Hello, world'</span></span><br><span class="line">s2 = <span class="string">'Hello, \'Adam\''</span></span><br><span class="line">s3 = <span class="string">r'Hello, "Bart"'</span></span><br><span class="line">s4 = <span class="string">r'''Hello,</span></span><br><span class="line"><span class="string">Lisa!'''</span></span><br><span class="line">print(n) <span class="comment"># 123</span></span><br><span class="line">print(f) <span class="comment"># 456.789</span></span><br><span class="line">print(s1) <span class="comment"># Hello, world</span></span><br><span class="line">print(s2) <span class="comment"># Hello, 'Adam'</span></span><br><span class="line">print(s3) <span class="comment"># Hello, "Bart"</span></span><br><span class="line">print(s4) </span><br><span class="line">Hello,</span><br><span class="line">Lisa!</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p><p>对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。</p><p>注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。</p><p>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</p><h1 id="二、字符串和编码"><a href="#二、字符串和编码" class="headerlink" title="二、字符串和编码"></a>二、字符串和编码</h1><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>字符串比较特殊的是有一个编码问题。</p><p>全世界有上百种语言，中国制定了GB2312编码，用来把中文编进去，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母A用ASCII编码是十进制的65，二进制的01000001；</p><p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p><p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p><p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th align="center">字符</th><th align="center">ASCII</th><th align="center">Unicode</th><th align="center">UTF-8</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">01000001</td><td align="center">00000000 01000001</td><td align="center">01000001</td></tr><tr><td align="center">中</td><td align="center">x</td><td align="center">01001110 00101101</td><td align="center">11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p><p>所以看到很多网页的源码上会有类似<meta charset="UTF-8">的信息，表示该网页正是用的UTF-8编码。</p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'包含中文的str'</span>) <span class="comment"># 包含中文的str</span></span><br></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ord(<span class="string">'A'</span>) <span class="comment"># 65</span></span><br><span class="line">ord(<span class="string">'中'</span>) <span class="comment"># 20013</span></span><br><span class="line">chr(<span class="number">66</span>) <span class="comment"># 'B'</span></span><br><span class="line">chr(<span class="number">25991</span>) <span class="comment"># '文'</span></span><br></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写str：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u4e2d\u6587'</span> <span class="comment"># '中文'</span></span><br></pre></td></tr></table></figure><p>两种写法完全是等价的。</p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>) <span class="comment"># b'ABC'</span></span><br><span class="line"><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>) <span class="comment"># b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="string">'中文'</span>.encode(<span class="string">'ascii'</span>) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p><p>在bytes中，无法显示为ASCII字符的字节，用\x##显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>) <span class="comment"># 'ABC'</span></span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>) <span class="comment"># '中文'</span></span><br></pre></td></tr></table></figure><p>如果bytes中包含无法解码的字节，decode()方法会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="comment"># '中'</span></span><br></pre></td></tr></table></figure><p>要计算str包含多少个字符，可以用len()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'ABC'</span>) <span class="comment"># 3</span></span><br><span class="line">len(<span class="string">'中文'</span>) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">b'ABC'</span>) <span class="comment"># 3</span></span><br><span class="line">len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 6</span></span><br><span class="line">len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p><strong>为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</strong></p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。</p><p>如果.py文件本身使用UTF-8编码，并且也申明了# -<em>- coding: utf-8 -</em>-，打开命令提示符测试就可以正常显示中文。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>最后一个常见的问题是如何输出格式化的字符串。</p><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hello, %s'</span> % <span class="string">'world'</span> </span><br><span class="line"><span class="comment"># 'Hello, world'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>) </span><br><span class="line"><span class="comment"># 'Hi, Michael, you have $1000000.'</span></span><br></pre></td></tr></table></figure><p>%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p><table><thead><tr><th align="center">占位符</th><th align="center">替换内容</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">整数</td></tr><tr><td align="center">%f</td><td align="center">浮点数</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%x</td><td align="center">十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%02d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)) <span class="comment"># 03-01</span></span><br><span class="line">print(<span class="string">'%.2f'</span> % <span class="number">3.1415926</span>) <span class="comment"># 3.14</span></span><br></pre></td></tr></table></figure><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Age: %s. Gender: %s'</span> % (<span class="number">25</span>, <span class="literal">True</span>) </span><br><span class="line"><span class="comment"># 'Age: 25. Gender: True'</span></span><br></pre></td></tr></table></figure><p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span><span class="string">' </span></span><br><span class="line"><span class="string"># growth rate: 7 %'</span></span><br></pre></td></tr></table></figure><p>另一种格式化字符串的方法是使用字符串的<strong>format()</strong>方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'</span>.format(<span class="string">'小明'</span>, <span class="number">17.125</span>) </span><br><span class="line"><span class="comment"># 'Hello, 小明, 成绩提升了 17.1%'</span></span><br></pre></td></tr></table></figure><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出’xx.x%’，只保留小数点后1位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="number">72</span></span><br><span class="line">s2 = <span class="number">85</span></span><br><span class="line">r = (s2-s1)/s1</span><br><span class="line">r = r*<span class="number">100</span></span><br><span class="line">print(<span class="string">'%.1f%%'</span> % r)</span><br><span class="line"><span class="comment"># 18.1%</span></span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Python 3的字符串使用Unicode，直接支持多语言。</p><p>当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中文'</span>.encode(<span class="string">'gb2312'</span>)</span><br><span class="line"><span class="comment"># b'\xd6\xd0\xce\xc4'</span></span><br></pre></td></tr></table></figure><p>但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。</p><p>格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。</p><h1 id="三、使用list和tuple"><a href="#三、使用list和tuple" class="headerlink" title="三、使用list和tuple"></a>三、使用list和tuple</h1><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>比如，列出班里所有同学的名字，就可以用一个list表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line">classmates</span><br><span class="line"><span class="comment"># ['Michael', 'Bob', 'Tracy']</span></span><br></pre></td></tr></table></figure><p>用len()函数可以获得list元素的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(classmates) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classmates[<span class="number">0</span>] <span class="comment"># 'Michael'</span></span><br><span class="line">classmates[<span class="number">1</span>] <span class="comment"># 'Bob'</span></span><br><span class="line">classmates[<span class="number">2</span>] <span class="comment"># 'Tracy'</span></span><br><span class="line">classmates[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>最后一个元素的索引是len(classmates)-1，以此类推，可以获取倒数第2个、倒数第3个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classmates[<span class="number">-1</span>] <span class="comment"># 'Tracy'</span></span><br><span class="line">classmates[<span class="number">-2</span>] <span class="comment">#'Bob'</span></span><br><span class="line">classmates[<span class="number">-3</span>] <span class="comment"># 'Michael'</span></span><br><span class="line">classmates[<span class="number">-4</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line">classmates</span><br><span class="line"><span class="comment"># ['Michael', 'Bob', 'Tracy', 'Adam']</span></span><br></pre></td></tr></table></figure><p>可以把元素插入到指定的位置，比如索引号为1的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classmates.insert(<span class="number">1</span>,<span class="string">'Jack'</span>)</span><br><span class="line">classmates</span><br><span class="line"><span class="comment"># ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']</span></span><br></pre></td></tr></table></figure><p>要删除list末尾的元素，用pop()方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classmates.pop()</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line">classmates</span><br><span class="line"><span class="comment"># ['Michael', 'Jack', 'Bob', 'Tracy']</span></span><br></pre></td></tr></table></figure><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line">classmates</span><br><span class="line"><span class="comment"># ['Michael', 'Bob', 'Tracy']</span></span><br></pre></td></tr></table></figure><p>list里面的元素的数据类型也可以不同，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure><p>list元素也可以是另一个list，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line">len(s) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line">s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure><p>要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple一旦初始化就不能修改，它也没有append()，insert()这样的方法。比如同样是列出同学的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</span><br></pre></td></tr></table></figure><p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>如果要定义一个空的tuple，可以写成()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = ()</span><br><span class="line">t <span class="comment"># ()</span></span><br></pre></td></tr></table></figure><p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>)</span><br><span class="line">t <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,)</span><br><span class="line">t <span class="comment"># (1,)</span></span><br></pre></td></tr></table></figure><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line">t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line">t</span><br><span class="line"><span class="comment"># ('a', 'b', ['X', 'Y'])</span></span><br></pre></td></tr></table></figure><p>我们先看看定义的时候tuple包含的3个元素：<br><img alt="img0" data-src="/images/python/0.jpg" class="lazyload"><br>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：<br><img alt="img1" data-src="/images/python/1.jpg" class="lazyload"><br>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>请用索引取出下面list的指定元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = [</span><br><span class="line">    [<span class="string">'Apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>],</span><br><span class="line">    [<span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Ruby'</span>, <span class="string">'PHP'</span>],</span><br><span class="line">    [<span class="string">'Adam'</span>, <span class="string">'Bart'</span>, <span class="string">'Lisa'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 打印Apple:</span></span><br><span class="line">print(L[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 打印Python:</span></span><br><span class="line">print(L[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 打印Lisa:</span></span><br><span class="line">print(L[<span class="number">2</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p><h1 id="四、条件判断"><a href="#四、条件判断" class="headerlink" title="四、条件判断"></a>四、条件判断</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure><h3 id="再议-input"><a href="#再议-input" class="headerlink" title="再议 input"></a>再议 input</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">'birth: '</span>)</span><br><span class="line">birth = int(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br></pre></td></tr></table></figure><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p>小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p><ul><li>低于18.5：过轻</li><li>18.5-25：正常</li><li>25-28：过重</li><li>28-32：肥胖</li><li>高于32：严重肥胖</li></ul><p>用if-elif判断并打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">1.75</span></span><br><span class="line">weight = <span class="number">80.5</span></span><br><span class="line">bmi = weight/(height)**<span class="number">2</span></span><br><span class="line">print(bmi)</span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">18.5</span>:</span><br><span class="line">    print(<span class="string">"过轻"</span>)</span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">25</span>:</span><br><span class="line">    print(<span class="string">"正常"</span>)</span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">28</span>:</span><br><span class="line">    print(<span class="string">"过重"</span>)</span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">32</span>:</span><br><span class="line">    print(<span class="string">"肥胖"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"严重肥胖"</span>)</span><br><span class="line"><span class="comment"># 过重</span></span><br></pre></td></tr></table></figure><h1 id="五、循环"><a href="#五、循环" class="headerlink" title="五、循环"></a>五、循环</h1><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Michael</span></span><br><span class="line"><span class="string">Bob</span></span><br><span class="line"><span class="string">Tracy</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。range(101)就可以生成0-100的整数序列，计算如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"><span class="comment"># 5050</span></span><br></pre></td></tr></table></figure><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><p>请利用循环依次对list中的每个名字打印出Hello, xxx!：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Bart'</span>, <span class="string">'Lisa'</span>, <span class="string">'Adam'</span>]</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">    print(<span class="string">"Hello, %s!"</span> % l)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Hello, Bart!</span></span><br><span class="line"><span class="string">Hello, Lisa!</span></span><br><span class="line"><span class="string">Hello, Adam!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>如果要提前结束循环，可以用break语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    print(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>如果我们想只打印奇数，可以用continue语句跳过某些循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。</p><p>可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。</p><p>不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。</p><h1 id="六、使用dict和set"><a href="#六、使用dict和set" class="headerlink" title="六、使用dict和set"></a>六、使用dict和set</h1><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>字典使用键-值（key-value）存储，具有极快的查找速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line">d[<span class="string">'Michael'</span>] <span class="comment"># 95</span></span><br></pre></td></tr></table></figure><p>为什么dict查找速度这么快？dict就是给定一个名字比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。</p><p>dict的key必须是不可变对象。list是可变对象，不能作为key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[key] = <span class="string">'a list'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set可以看成数学意义上的无序和无重复元素的集合。<br>set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>显示的顺序也不表示set是有序的。<br>重复元素在set中自动被过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">s <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过remove(key)方法可以删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.remove(<span class="number">4</span>)</span><br><span class="line">s <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">s1 &amp; s2 <span class="comment"># &#123;2, 3&#125;</span></span><br><span class="line">s1 | s2 <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>再议不可变对象<br>str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line">a.sort()</span><br><span class="line">a <span class="comment"># ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p>而对于不可变对象，比如str，对str进行操作呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'abc'</span></span><br><span class="line">a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>) <span class="comment"># 'Abc'</span></span><br><span class="line">a <span class="comment"># 'abc'</span></span><br></pre></td></tr></table></figure><p>虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？</p><p>我们先把代码改成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'abc'</span></span><br><span class="line">b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</span><br><span class="line">b <span class="comment"># 'Abc'</span></span><br><span class="line">a <span class="comment"># 'abc'</span></span><br></pre></td></tr></table></figure><p>要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’：<br><img alt="img2" data-src="/images/python/2.png" class="lazyload"><br>当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了：<br><img alt="img3" data-src="/images/python/3.png" class="lazyload"><br>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。</p><p>tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。</p><p>本节参考自廖雪峰老师的python教程，链接是：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
