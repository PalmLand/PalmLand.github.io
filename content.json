{"meta":{"title":"PalmLand","subtitle":"Haha, genius!","description":"This is our history.","author":"PalmLand","url":"https://palmland.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-06-29T01:24:14.000Z","updated":"2019-06-29T01:25:05.343Z","comments":false,"path":"categories/index.html","permalink":"https://palmland.github.io/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2019-12-01T07:49:38.000Z","updated":"2019-12-01T07:50:00.041Z","comments":true,"path":"link/index.html","permalink":"https://palmland.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-29T01:26:27.000Z","updated":"2019-12-01T07:47:49.671Z","comments":true,"path":"tags/index.html","permalink":"https://palmland.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"毕业设计：基于OpenCV的手势识别系统设计与实现","slug":"毕业设计：基于OpenCV的手势识别系统设计与实现","date":"2019-12-14T13:30:05.000Z","updated":"2019-12-14T14:51:59.943Z","comments":true,"path":"2019/12/14/毕业设计：基于OpenCV的手势识别系统设计与实现/","link":"","permalink":"https://palmland.github.io/2019/12/14/毕业设计：基于OpenCV的手势识别系统设计与实现/","excerpt":"categories: 基于计算指间夹角数量的手势识别模块实现 基于卷积神经网络的手势识别模块实现 基于手势的游戏交互应用","text":"categories: 基于计算指间夹角数量的手势识别模块实现 基于卷积神经网络的手势识别模块实现 基于手势的游戏交互应用 1 基于计算指间夹角数量的手势识别模块实现1.1 图像预处理模块先进行图像预处理减少图像噪声，恢复有用的信息，提高相关信息的可检测性最小化数据，来增强图像分割、匹配和识别的可靠性。 首先使用基于高斯混合的背景/前景分割算法来去除背景，这里使用OpenCV的内置函数createBackgroundSubtractorMOG2()来去除背景。 1bgModel = cv2.createBackgroundSubtractorMOG2(0, bgSubThreshold) 然后建立一个背景减法器模型： 1fgmask = bgModel.apply(frame) 将模型运用到每一帧上： 1res = cv2.bitwise_and(frame, frame, mask=fgmask) 就能得到如图1-1所示的手的前景图像：这样得到的图像还不能将想要的手势从复杂的背景中分离出来，所以还需要进行二值化处理。 先使用cv2.COLOR_BGR2GRAY将RGB图像转化为灰度图： 1gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 再使用cv2.GaussianBlur()函数用高斯滤波器对图像进行平滑处理，减少噪声： 1blur = cv2.GaussianBlur(gray, (blurValue, blurValue), 0) 最后通过cv2.threshold()进行阈值处理，使得图像的像素值更单一、图像更简单： 1ret, thresh = cv2.threshold(blur, threshold, 255, cv2.THRESH_BINARY) 阈值处理是基于特定阈值水平将像素强度分配为0和1，以便仅从图像捕获感兴趣的对象。这样就能从多值的数字图像中直接提取出目标物体。 设计当按下键盘上的“B”时该模块被触发，实现代码如下： 1234elif k == ord(&apos;b&apos;): # press &apos;b&apos; to capture the background bgModel = cv2.createBackgroundSubtractorMOG2(0, bgSubThreshold) isBgCaptured = 1 print( &apos;!!!Background Captured!!!&apos;) 图像预处理结果如图1-2所示： 1.2 轮廓获取模块使用cv2.findContours()函数查找检测物体的轮廓，然后通过for循环找到区域内最大的轮廓。再根据图像的轮廓点，通过convexhull()函数转化成凸包的点坐标，从而分别画出手和凸包的轮廓。 这个函数将从二值图像中找到所有的轮廓： 1contours,hierarchy=cv2.findContours(thresh1,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) 需要得到手基于其面积的最大轮廓，这里可以假设手是最大的轮廓。使用for循环得到该轮廓： 123456for i in range(length):temp = contours[i] area = cv2.contourArea(temp) if area &gt; maxArea: maxArea = area ci = i 根据图像的轮廓点，通过convexHull()函数转化成凸包的点坐标，从而画出图像的凸包。 1hull = cv2.convexHull(res) 分别画出手和凸包的轮廓，如图1-3所示，绿色线条为手的轮廓，红色线条是凸包的轮廓。 12cv2.drawContours(drawing, [res], 0, (0, 255, 0), 2)cv2.drawContours(drawing, [hull], 0, (0, 0, 255), 5) 在图1-3中，红色的轮廓线就是凸包(convexity hull), 而凸包与手掌之间的部分就是凸缺陷(convexity defects)，即对象上的任何凹陷。每个凸缺陷区域有四个特征量：起始点(startPoint)，结束点(endPoint)，距离凸包最远点(farPoint)，最远点到凸包的距离(depth)。如图1-4所示，蓝色的点就是凸缺陷的起始点和结束点，红色的点为最远的点。 最后使用cv.convexityDefect()函数找到凸缺陷。 1defects = cv2.convexityDefects(res, hull) 1.3 特征提取模块图1-4中大拇指和食指构成的三角形可以具体化为图1-5所示的三角形，设定大拇指和食指的夹角为A，其余两个角为B和C，它们的对边分别为a，b，c。如下代码可以计算三角形每边的长度： 1234# find length of all sides of trianglea = math.sqrt((end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2)b = math.sqrt((far[0] - start[0]) ** 2 + (far[1] - start[1]) ** 2)c = math.sqrt((end[0] - far[0]) ** 2 + (end[1] - far[1]) ** 2) 使用余弦定理的变形公式（公式(1)）计算角A。 $\\cos(A)=(b^2+c^2-a^2)/2bc$ (1) 然后使用math.acos()函数获得夹角的反余弦弧度值，通过它可以得到手指间的夹角。如果夹角小于90°就视为是两个手指之间的夹角，通过夹角数量来判断手指个数。代码如下： 123angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) if angle &lt;= math.pi / 2: cnt += 1 1.4 手势识别模块当按下键盘上的“N”时，系统开始识别手势类型，实现代码如下： 123elif k == ord(&apos;n&apos;): triggerSwitch = True print (&apos;!!!Trigger On!!!&apos;) 当该模块被触发时，控制台会输出手势类型，识别代码如下： 123if triggerSwitch is True: if isFinishCal is True: print (&quot;finger&quot;+str(cnt+1))# cnt是点的数量，+1表示手指数量 2 基于卷积神经网络的手势识别模块实现2.1 图像预处理及数据集生成模块手势识别的第一步是通过消除视频序列中的其他不需要的部分来找到手区域。这里使用的是背景消除法，其原理如图2-1所示。这里让系统查看特定场景30帧，在此期间，计算当前帧和前一帧的运行平均值。通过这样做，告诉系统它盯着的这30帧的平均运行视频序列是背景。在弄清楚背景之后，把手放进去，通过背景消除法让系统理解手是前景对象。计算背景模型（随时间更新）和当前帧（有手的帧）之间的绝对差值，以获得保存新添加的前景对象的差异图像。这就是背景消除法的全部内容。为了从这个差异图像中检测手部区域，需要对差异图像进行阈值处理，以便只有手部区域变得可见，而所有其他不需要的区域都被涂成黑色。这就是运动检测的全部意义所在。在对差异图像进行阈值处理后，在得到的图像中找到轮廓，假设面积最大的轮廓是手。因此，从视频序列中找到手区域的第一步涉及三个简单步骤： 1) 背景消除法 2) 运动检测和阈值处理 3) 轮廓获取 现在，将通过代码实现以上步骤。 123456789def run_avg(image, aWeight): global bg # initialize the background if bg is None: bg = image.copy().astype(&quot;float&quot;) return # compute weighted average, accumulate it and update the background cv2.accumulateWeighted(image, bg, aWeight) run_avg()函数用于计算背景模型和当前帧之间的运行平均值。此函数接受两个参数:当前帧和aWeight，它类似于在图像上执行运行平均值的阈值。如果背景模型为None（即如果它是第一帧），则用当前帧初始化它。然后，使用cv2.accumulateWeighted()函数计算背景模型和当前帧的运行平均值。运行平均值使用式(2)给出的公式计算: $dst(x,y)=(1-a).dst(x,y)+a.src(x,y)$ (2) src(x,y):源图像或输入图像（1或3通道，8位或32位浮点数） dst(x,y):目标图像或输出图像（与源图像相同的通道，32位或64位浮点数） a:源图像的权重（输入图像）12345678910111213141516def segment(image, threshold=25): global bg # find the absolute difference between background and current frame diff = cv2.absdiff(bg.astype(&quot;uint8&quot;), image) # threshold the diff image so that we get the foreground thresholded = cv2.threshold(diff, threshold, 255, cv2.THRESH_BINARY) # get the contours in the thresholded image (_, cnts, _) = cv2.findContours(thresholded.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # return None, if no contours detected if len(cnts) == 0: return else: # based on contour area, get the maximum contour which is the hand segmented = max(cnts, key=cv2.contourArea) return (thresholded, segmented) 下一个函数segment()是用于从视频序列中分割手区域。此函数包含两个参数：当前帧和阈值，用于对差值图像进行阈值处理。首先，使用cv2.absdiff()函数找到背景模型和当前帧之间的绝对差异。 接下来，使用cv2.threshold()函数对差异图像进行阈值处理以仅显示手部区域。最后，使用cv2.findContours()函数在阈值图像上执行轮廓获取，并获取具有最大面积的轮廓（这是手）。将阈值图像以及分割图像作为元组返回。如果x(n)表示特定像素坐标处的输入图像的像素强度，则threshold决定将图像分割/阈值到二值图像的程度。 系统必须寻找手区域，因此将尝试最小化识别区域，而不是从整个视频序列中识别手势。要突出显示此区域，使用cv2.rectangle()函数，该函数需要顶部，右侧，底部和左侧像素坐标。 12# draw the segmented handcv2.rectangle(clone, (left, top), (right, bottom), (0,255,0), 2) 为了跟踪帧数，初始化变量num_frames。然后，开始一个无限循环，并使用camera.read()函数从网络摄像头读取帧。 然后，将输入帧的大小调整为700像素的固定宽度，使用imutils库保持宽高比并翻转帧以避免镜像视图。 12345678# get the current frame(grabbed, frame) = camera.read()# resize the frameframe = imutils.resize(frame, width=700)# flip the frame so that it is not the mirror viewframe = cv2.flip(frame, 1) 接下来，使用简单的NumPy切片仅取出感兴趣的区域（即识别区域）。然后，将此ROI转换为灰度图像，并使用高斯模糊来最小化图像中的高频分量。在超过30帧之前，继续将输入帧添加到run_avg()函数并更新背景模型。 123456789101112# get the ROIroi = frame[top:bottom, right:left]# convert the roi to grayscale and blur itgray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)gray = cv2.GaussianBlur(gray, (7, 7), 0)# to get the background, keep looking till a threshold is reached# so that our running average model gets calibratedif num_frames &lt; 30:run_avg(gray, aWeight)print(num_frames) 在更新背景模型之后，将当前输入帧传递到segment()函数中，并返回阈值化图像和分割图像。使用cv2.drawContours()在帧上绘制分段轮廓，并使用cv2.imshow()显示阈值输出。 1234567891011# segment the hand regionhand = segment(gray)# check whether hand region is segmentedif hand is not None:# if yes, unpack the thresholded image and# segmented region (thresholded, segmented) = hand # draw the segmented region and display the frame cv2.drawContours(clone, [segmented + (right, top)], -1, (0, 0, 255)) 最后，在当前帧中显示分割的手势区域如图2-2所示，并等待按键退出程序。 使用如下代码保存图片，每种手势生成1000张图片作为训练集。该模块原本是想作为基于计算指间夹角数量的手势识别模块的补充，识别手势六到十，但是训练集会过于庞大，训练时间太长，值采集了手势零（握拳）、手势五（手掌）和手势六，生成的部分训练数据如图2-3、2-4、2-5所示。 1234if start_recording:# Mention the directory in which you wanna store the images followed by the image namecv2.imwrite(&quot;Dataset/FistImages/fist_&quot; + str(image_num) + &apos;.png&apos;, thresholded)image_num += 1 2.2 图像大小调整模块使用tensorflow设计的卷积神经网络接受89*100的二维单通道图像,因此需要调整图像大小，使用如下代码实现： 1234567def resizeImage(imageName): basewidth = 100 img = Image.open(imageName) wpercent = (basewidth/float(img.size[0])) hsize = int((float(img.size[1])*float(wpercent))) img = img.resize((basewidth,hsize), Image.ANTIALIAS) img.save(imageName) 2.3 模型训练模块本次训练模型使用的是TFLearn，TFLearn建立在tensorflow上的一个深度学习库，提供了基于tensorflow的高层API接口，有助于快速构建深度学习网络，大大减少代码冗余。该神经网络包含7个隐藏卷积层，其中relu作为激活函数，1个全连接层。该网络经过50次迭代的训练，每次的batch size为64。现在来定义网络结构的输入层和隐藏层： 123456789101112131415161718192021convnet=input_data(shape=[None,89,100,1],name=&apos;input&apos;)convnet=conv_2d(convnet,32,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,64,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,128,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,256,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,256,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,128,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2)convnet=conv_2d(convnet,64,2,activation=&apos;relu&apos;)convnet=max_pool_2d(convnet,2) 再来定义全连接层和输出层： 123convnet=fully_connected(convnet,1000,activation=&apos;relu&apos;)convnet=dropout(convnet,0.75)convnet=fully_connected(convnet,3,activation=&apos;softmax&apos;) 使用tflearn的DNN类中的fit()函数训练模型： 123model.fit(loadedImages, outputVectors, n_epoch=50, validation_set = (testImages, testLabels), snapshot_step=100, show_metric=True, run_id=&apos;convnet_coursera&apos;) 然后保存模型： 1model.save(&quot;TrainedModel/GestureRecogModel.tfl&quot;) 2.4 手势识别模块先载入之前训练好的模型： 1model.load(&quot;TrainedModel/GestureRecogModel.tfl&quot;) prefict()函数可以给定输入数据的模型预测，获得预测的手势种类： 1prediction = model.predict([gray_image.reshape(89, 100, 1)]) 然后返回预测的手势类型以及概率： 12345678910return np.argmax(prediction), (np.amax(prediction) / (prediction[0][0] + prediction[0][1] + prediction[0][2]))```将获得的手势编号转化成手势名称：```if predictedClass == 0:className = &quot;Swing&quot;elif predictedClass == 1:className = &quot;Palm&quot;elif predictedClass == 2:className = &quot;Fist&quot; 将手势名称及概率显示在屏幕上： 12345cv2.putText(textImage,&quot;Pedicted Class : &quot; + className, (30, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2) cv2.putText(textImage,&quot;Confidence : &quot; + str(confidence * 100) + &apos;%&apos;, (30, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)cv2.imshow(&quot;Statistics&quot;, textImage) 得到的效果如图2-6所示： 3 基于手势的游戏交互应用游戏效果如下图所示： 4 手势识别效果演示4.1 基于计算指间夹角数量的手势识别模块实现 4.2 基于卷积神经网络的手势识别模块实现","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://palmland.github.io/tags/Machine-Learning/"}],"author":"PalmLand"},{"title":"《机器学习实战》-01参考笔记","slug":"《机器学习实战》-01笔记","date":"2019-08-19T02:02:49.000Z","updated":"2019-12-13T06:44:03.485Z","comments":true,"path":"2019/08/19/《机器学习实战》-01笔记/","link":"","permalink":"https://palmland.github.io/2019/08/19/《机器学习实战》-01笔记/","excerpt":"本书笔记来源于Apachecn，该书分为四部分： 2~7章讲分类 8~9章讲回归 10~12章讲无监督学习 13~15章讲机器学习算法使用到的附属工具 该笔记增加了第16章推荐系统，作为实战项目","text":"本书笔记来源于Apachecn，该书分为四部分： 2~7章讲分类 8~9章讲回归 10~12章讲无监督学习 13~15章讲机器学习算法使用到的附属工具 该笔记增加了第16章推荐系统，作为实战项目 第一章: 机器学习基础 第二章: KNN 近邻算法 第三章: 决策树 第四章: 朴素贝叶斯 第五章: Logistic回归 第六章: SVM 支持向量机 第七章: 集成方法（随机森林和 AdaBoost） 第八章: 回归 第九章: 树回归 第十章: K-Means 聚类 第十一章: 利用 Apriori 算法进行关联分析 第十二章: FP-growth 高效发现频繁项集 第十三章: 利用 PCA 来简化数据 第十四章: 利用 SVD 来简化数据 第十五章: 大数据与 MapReduce 第十六章: 推荐系统（已迁移）","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://palmland.github.io/tags/Machine-Learning/"}],"author":"PalmLand"},{"title":"机器学习路线","slug":"机器学习路线","date":"2019-07-30T14:02:28.000Z","updated":"2019-12-01T08:29:38.923Z","comments":true,"path":"2019/07/30/机器学习路线/","link":"","permalink":"https://palmland.github.io/2019/07/30/机器学习路线/","excerpt":"","text":"《A Guide to Intelligent Systems》； 《机器学习》周志华Z1-Z10； 《Python机器学习及实践》； Python&amp;numpy,pandas,matplotlib,sklearn； 谷歌机器学习课程； Udacity: Intro to TensorFlow for Deep Learning by TensorFlow； Tensorflow； Kaggle；","categories":[],"tags":[],"author":"PalmLand"},{"title":"Python-06Matplotlib","slug":"python-06Matplotlib","date":"2019-07-16T01:14:33.000Z","updated":"2019-12-01T08:30:20.598Z","comments":true,"path":"2019/07/16/python-06Matplotlib/","link":"","permalink":"https://palmland.github.io/2019/07/16/python-06Matplotlib/","excerpt":"基本介绍 选择数据","text":"基本介绍 选择数据 Matplotlib 是一个非常强大的 Python 画图工具。它能帮你画出美丽的: 线图，散点图，等高线图，条形图，柱状图，3D 图形，甚至是图形动画等等。 一、基本语法使用import导入模块matplotlib.pyplot： 12import matplotlib.pyplot as pltimport numpy as np 使用np.linspace定义x：范围是(-1,1);个数是50. 仿真一维数据组(x ,y)表示曲线1。 12x = np.linspace(-1, 1, 50)y = 2*x + 1 使用plt.figure定义一个图像窗口，使用plt.plot画(x ,y)曲线，使用plt.show显示图像。 123plt.figure()plt.plot(x, y)plt.show() figure图像matplotlib 的 figure 就是一个 单独的 figure 小窗口, 小窗口里面还可以有更多的小图片。 123x = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2 使用plt.figure定义一个图像窗口. 使用plt.plot画(x ,y1)曲线。 123plt.figure()plt.plot(x, y1)plt.show() 使用plt.figure定义一个图像窗口：编号为3；大小为(8, 5). 使用plt.plot画(x ,y2)曲线. 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线. 使用plt.show显示图像。 1234plt.figure(num=3, figsize=(8, 5),)plt.plot(x, y2)plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--')plt.show() 设置坐标轴调整名字和间隔使用np.linspace定义x：范围是(-3,3);个数是50. 仿真一维数据组(x ,y1)表示曲线1. 仿真一维数据组(x ,y2)表示曲线2. 123x = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2 使用plt.figure定义一个图像窗口. 使用plt.plot画(x ,y2)曲线. 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线. 123plt.figure()plt.plot(x, y2)plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') 使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)； 使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’； 12345plt.xlim((-1, 2))plt.ylim((-2, 3))plt.xlabel('I am x')plt.ylabel('I am y')plt.show() 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5. 123new_ticks = np.linspace(-1, 2, 5)print(new_ticks)plt.xticks(new_ticks) 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像. 12plt.yticks([-2, -1.8, -1, 1.22, 3],[r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$'])plt.show() 设置不同名字和位置使用np.linspace定义x：范围是(-3,3);个数是50. 仿真一维数据组(x ,y1)表示曲线1. 仿真一维数据组(x ,y2)表示曲线2. 12345678910111213import numpy as npimport pandas as pdimport matplotlib.pyplot as pltx = np.linspace(-3,3,50)y1 = 2*x + 1y2 = x**2plt.figure()plt.plot(x,y2)plt.plot(x,y1,color='red',linewidth=1.0,linestyle='--')plt.xlim((-1,2))plt.ylim((-2,3)) 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5. 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 123new_ticks = np.linspace(-1,2,5)plt.xticks(new_ticks)plt.yticks([-2,-1.8,-1,1.22,3],['$really\\ bad$','$bad$','$normal$','$good$','$really\\ good$']) 使用plt.gca获取当前坐标轴信息。使用.spines设置边框： 右侧边框，使用.set_color设置边框颜色：默认白色； 上边框，使用.set_color设置边框颜色：默认白色； 12345# gca = get current axisax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')plt.show() 调整坐标轴使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom（所有位置：top，bottom，both，default，none） 1ax.xaxis.set_ticks_position('bottom') 使用.spines设置边框：x轴；使用.set_position设置边框位置在y=0处；（位置所有属性：outward，axes，data） 1ax.spines['bottom'].set_position(('data',0)) 同理，设置y轴的刻度和坐标的位置：· 1234ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0))plt.show() 本节参考自莫烦python，学习请点击：https://morvanzhou.github.io/tutorials/data-manipulation/plt/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}],"author":"PalmLand"},{"title":"Python-05Pandas","slug":"python-05Pandas","date":"2019-07-15T03:03:45.000Z","updated":"2019-08-12T12:44:27.204Z","comments":true,"path":"2019/07/15/python-05Pandas/","link":"","permalink":"https://palmland.github.io/2019/07/15/python-05Pandas/","excerpt":"基本介绍 选择数据 设置值 处理丢失数据 导入导出 合并concat 合并merge plot出图","text":"基本介绍 选择数据 设置值 处理丢失数据 导入导出 合并concat 合并merge plot出图 一、基本介绍如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。 要使用pandas，首先需要了解他主要两个数据结构：Series和DataFrame。 SeriesSeries的字符串表现形式为：索引在左边，值在右边。 1234567891011121314import pandas as pdimport numpy as nps = pd.Series([1,3,6,np.nan,44,1])print(s)\"\"\"0 1.01 3.02 6.03 NaN4 44.05 1.0dtype: float64\"\"\" 由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为长度）的整数型索引。 DataFrameDataFrame是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。 12345678910111213dates = pd.date_range('20160101',periods=6)df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=['a','b','c','d'])print(df)\"\"\" a b c d2016-01-01 -0.253065 -2.071051 -0.640515 0.6136632016-01-02 -1.147178 1.532470 0.989255 -0.4997612016-01-03 1.221656 -2.390171 1.862914 0.7780702016-01-04 1.473877 -0.046419 0.610046 0.2046722016-01-05 -1.584752 -0.700592 1.487264 -1.7782932016-01-06 0.633675 -1.414157 -0.277066 -0.442545\"\"\" 可以根据每一个不同的索引来挑选数据, 比如挑选 b 的元素： 12345678910print(df['b'])\"\"\"2016-01-01 -2.0710512016-01-02 1.5324702016-01-03 -2.3901712016-01-04 -0.0464192016-01-05 -0.7005922016-01-06 -1.414157Freq: D, Name: b, dtype: float64\"\"\" 创建一组没有给定行标签和列标签的数据 df1，它就会采取默认的从0开始 index: 12345678df1 = pd.DataFrame(np.arange(12).reshape((3,4)))print(df1)\"\"\" 0 1 2 30 0 1 2 31 4 5 6 72 8 9 10 11\"\"\" 还有一种生成 df 的方法, 如下 df2: 1234567891011121314df2 = pd.DataFrame(&#123;'A' : 1., 'B' : pd.Timestamp('20130102'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D' : np.array([3] * 4,dtype='int32'), 'E' : pd.Categorical([\"test\",\"train\",\"test\",\"train\"]), 'F' : 'foo'&#125;)print(df2)\"\"\" A B C D E F0 1.0 2013-01-02 1.0 3 test foo1 1.0 2013-01-02 1.0 3 train foo2 1.0 2013-01-02 1.0 3 test foo3 1.0 2013-01-02 1.0 3 train foo\"\"\" 如果想要查看数据中的类型, 我们可以用 dtype 这个属性: 12345678910print(df2.dtypes)\"\"\"A float64B datetime64[ns]C float32D int32E categoryF objectdtype: object\"\"\" 如果想看对列的序号: 12print(df2.index)# Int64Index([0, 1, 2, 3], dtype='int64') 每种数据的名称也能看到: 12print(df2.columns)# Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object') 如果只想看所有df2的值: 1234567print(df2.values)\"\"\"array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'], [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object)\"\"\" 想知道数据的总结, 可以用 describe(): 1234567891011df2.describe()\"\"\" A C Dcount 4.0 4.0 4.0mean 1.0 1.0 3.0std 0.0 0.0 0.0min 1.0 1.0 3.025% 1.0 1.0 3.050% 1.0 1.0 3.075% 1.0 1.0 3.0max 1.0 1.0 3.0 如果想翻转数据, transpose: 12345678910111213141516171819print(df2.T)\"\"\" 0 1 2 \\A 1 1 1 B 2013-01-02 00:00:00 2013-01-02 00:00:00 2013-01-02 00:00:00 C 1 1 1 D 3 3 3 E test train test F foo foo foo 3 A 1 B 2013-01-02 00:00:00 C 1 D 3 E train F foo \"\"\" 如果想对数据的 index 进行排序并输出: 123456789# 按列倒序排序df2.sort_index(axis=1,ascending=False)\"\"\" F E D C B A0 foo test 3 1.0 2013-01-02 1.01 foo train 3 1.0 2013-01-02 1.02 foo test 3 1.0 2013-01-02 1.03 foo train 3 1.0 2013-01-02 1.0\"\"\" 123456789# 按行倒序排序df2.sort_index(axis=0,ascending=False)\"\"\" A B C D E F3 1.0 2013-01-02 1.0 3 train foo2 1.0 2013-01-02 1.0 3 test foo1 1.0 2013-01-02 1.0 3 train foo0 1.0 2013-01-02 1.0 3 test foo\"\"\" 如果是对数据值排序输出: 123456df2.sort_values(by='E') A B C D E F0 1.0 2013-01-02 1.0 3 test foo2 1.0 2013-01-02 1.0 3 test foo1 1.0 2013-01-02 1.0 3 train foo3 1.0 2013-01-02 1.0 3 train foo 二、选择数据建立了一个 6X4 的矩阵数据。 123456789101112dates = pd.date_range('20190721',periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=['A','B','C','D'])\"\"\"df A B C D2019-07-21 0 1 2 32019-07-22 4 5 6 72019-07-23 8 9 10 112019-07-24 12 13 14 152019-07-25 16 17 18 192019-07-26 20 21 22 23\"\"\" 简单的筛选如果我们想选取DataFrame中的数据，下面描述了两种途径, 他们都能达到同一个目的： 1234567891011121314151617181920df['A']\"\"\"2019-07-21 02019-07-22 42019-07-23 82019-07-24 122019-07-25 162019-07-26 20Freq: D, Name: A, dtype: int32\"\"\"df.A\"\"\"2019-07-21 02019-07-22 42019-07-23 82019-07-24 122019-07-25 162019-07-26 20Freq: D, Name: A, dtype: int32\"\"\" 让选择跨越多行或多列: 12345678910111213141516df[0:3]\"\"\" A B C D2019-07-21 0 1 2 32019-07-22 4 5 6 72019-07-23 8 9 10 11\"\"\"# 选择20190722到20190725标签之间的数据，并且包括这两个标签df['20190722':'20190725']\"\"\" A B C D2019-07-22 4 5 6 72019-07-23 8 9 10 112019-07-24 12 13 14 152019-07-25 16 17 18 19\"\"\" 根据标签 loc使用loc通过标签名字选择某一行数据，或者通过选择某行或者所有行（:代表所有行）然后选其中某一列或几列数据。 123456789101112131415161718df.loc['20190722']\"\"\"A 4B 5C 6D 7Name: 2019-07-22 00:00:00, dtype: int32\"\"\"df.loc[:,['A','B']]\"\"\" A B2019-07-21 0 12019-07-22 4 52019-07-23 8 92019-07-24 12 132019-07-25 16 172019-07-26 20 21\"\"\" 根据序列 iloc使用iloc通过位置选择在不同情况下所需要的数据。例如选某一个，连续选或者跨行选等操作。 12345678910111213141516171819202122df.iloc[3]\"\"\"A 12B 13C 14D 15Name: 2019-07-24 00:00:00, dtype: int32\"\"\"df.iloc[3,1] # 13df.iloc[3:5,0:3]\"\"\" A B C2019-07-24 12 13 142019-07-25 16 17 18\"\"\"df.iloc[[1,3,5],0:3]\"\"\" A B C2019-07-22 4 5 62019-07-24 12 13 142019-07-26 20 21 22\"\"\" 混合选择 ix可以采用混合选择ix, 其中选择’A’和’C’的两列，并选择前三行的数据。 1234567df.ix[:3,['A','C']]\"\"\" A C2019-07-21 0 22019-07-22 4 62019-07-23 8 10\"\"\" 通过判断的筛选可以采用判断指令 (Boolean indexing)约束某项条件然后选择出当前所有数据。 1234567df[df.A&gt;8]\"\"\" A B C D2019-07-24 12 13 14 152019-07-25 16 17 18 192019-07-26 20 21 22 23\"\"\" 三、设置值创建数据首先建立了一个 6X4 的矩阵数据。 123456789101112dates = pd.date_range('20130101', periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates, columns=['A','B','C','D'])\"\"\" A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23\"\"\" 根据位置设置 loc 和 iloc我们可以利用索引或者标签确定需要修改值的位置。 123456789101112df.iloc[2,2] = 1111df.loc['20130101','B'] = 2222\"\"\" A B C D2013-01-01 0 2222 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23\"\"\" 根据条件设置如果现在的判断条件是这样, 对于A大于4的行，更改df在相应行上的所有数为9999。 1234567891011df[df.A&gt;4] = 9999df\"\"\" A B C D2019-07-21 0 1 2 32019-07-22 4 2222 6 72019-07-23 9999 9999 9999 99992019-07-24 9999 9999 9999 99992019-07-25 9999 9999 9999 99992019-07-26 9999 9999 9999 9999\"\"\" 将A列中所有大于9998的值都改为9： 1234567891011df.A[df.A&gt;9998]=9df\"\"\" A B C D2019-07-21 0 1 2 32019-07-22 4 2222 6 72019-07-23 9 9999 9999 99992019-07-24 9 9999 9999 99992019-07-25 9 9999 9999 99992019-07-26 9 9999 9999 9999\"\"\" 对于A大于8的位置，更改B在相应位置上的数为9。 1234567891011df.B[df.A&gt;8]=9df\"\"\" A B C D2019-07-21 0 1 2 32019-07-22 4 2222 6 72019-07-23 9 9 9999 99992019-07-24 9 9 9999 99992019-07-25 9 9 9999 99992019-07-26 9 9 9999 9999\"\"\" 按行或列设置如果对整列做批处理, 加上一列 ‘F’, 并将 F 列全改为 NaN, 如下: 1234567891011df['F']=np.nandf\"\"\" A B C D F2019-07-21 0 1 2 3 NaN2019-07-22 4 2222 6 7 NaN2019-07-23 9 9 9999 9999 NaN2019-07-24 9 9 9999 9999 NaN2019-07-25 9 9 9999 9999 NaN2019-07-26 9 9 9999 9999 NaN\"\"\" 添加数据用上面的方法也可以加上 Series 序列（但是长度必须对齐）。 1234567891011df['E']=pd.Series([1,2,3,4,5,6],index=pd.date_range('20190721',periods=6))df\"\"\" A B C D F E2019-07-21 0 1 2 3 NaN 12019-07-22 4 2222 6 7 NaN 22019-07-23 9 9 9999 9999 NaN 32019-07-24 9 9 9999 9999 NaN 42019-07-25 9 9 9999 9999 NaN 52019-07-26 9 9 9999 9999 NaN 6\"\"\" 四、处理丢失数据创建含 NaN 的矩阵有时候我们导入或处理数据, 会产生一些空的或者是 NaN 数据。建立一个6X4的矩阵数据并且把两个位置置为空。 12345678910111213df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=['A','B','C','D'])df.iloc[0,1] = np.nandf.iloc[1,2] = np.nandf\"\"\" A B C D2013-01-01 0 NaN 2.0 32013-01-02 4 5.0 NaN 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23\"\"\" pd.dropna()如果想直接去掉有 NaN 的行或列, 可以使用 dropna： 1234567891011df.dropna( axis=0, # 0: 对行进行操作; 1: 对列进行操作 how='any' # 'any': 只要存在 NaN 就 drop 掉; 'all': 必须全部是 NaN 才 drop )\"\"\" A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23\"\"\" pd.fillna()如果是将 NaN 的值用其他值代替, 比如代替成 0: 12345678910df.fillna(value=0)\"\"\" A B C D2013-01-01 0 0.0 2.0 32013-01-02 4 5.0 0.0 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23\"\"\" pd.isnull()判断是否有缺失数据 NaN, 为 True 表示缺失数据: 12345678910df.isnull()\"\"\" A B C D2013-01-01 False True False False2013-01-02 False False True False2013-01-03 False False False False2013-01-04 False False False False2013-01-05 False False False False2013-01-06 False False False False\"\"\" 检测在数据中是否存在 NaN, 如果存在就返回 True: 12np.any(df.isnull()) == True# True 五、导入导出pandas可以读取与存取的资料格式有很多种，像csv、excel、json、html与pickle等…，详细请看官方说明文件 读取csv示范档案下载 - student.csv 123456789101112131415161718192021222324import pandas as pd #加载模块#读取csvdata = pd.read_csv('D:\\B\\hexo\\source\\_posts\\student.csv')#打印出dataprint(data)\"\"\" Student ID name age gender0 1100.0 Kelly 22.0 Female1 1101.0 Clo 21.0 Female2 1102.0 Tilly 22.0 Female3 1103.0 Tony 24.0 Male4 1104.0 David 20.0 Male5 1105.0 Catty 22.0 Female6 1106.0 M 3.0 Female7 1107.0 N 43.0 Male8 1108.0 A 13.0 Male9 1109.0 S 12.0 Male10 1110.0 David 33.0 Male11 1111.0 Dw 3.0 Female12 1112.0 Q 23.0 Male13 1113.0 W 21.0 Female\"\"\" 将资料存取成其他格式比如保存成pickle文件 1data.to_pickle(\"D:\\B\\hexo\\source\\_posts\\student.pickle\") 就可以看到文件夹下产生了一个pickle文件： 六、合并 concat使用 concat是一种基本的合并方式.而且concat中有很多参数可以调整,合并成你想要的数据形式。 axis(合并方向)axis=0是预设值，因此未设定任何参数时，函数默认axis=0，即按行合并（纵向）。 12345678910111213141516171819202122232425import pandas as pdimport numpy as np#定义数据集df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])df3 = pd.DataFrame(np.ones((3,4))*2, columns=['a','b','c','d'])#concat纵向合并res = pd.concat([df1, df2, df3], axis=0)#打印结果print(res)\"\"\" a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.00 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.00 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0\"\"\" ignore_index(重置 index)仔细观察会发现结果的index是0, 1, 2, 0, 1, 2, 0, 1, 2，若要将index重置，需要加上参数ignore_index (重置 index)： 1234567891011121314151617#承上一个例子，并将index_ignore设定为Trueres = pd.concat([df1, df2, df3], axis=0, ignore_index=True)#打印结果print(res)\"\"\" a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0\"\"\" 结果的index变0, 1, 2, 3, 4, 5, 6, 7, 8。 join(合并方式)join=’outer’为预设值，因此未设定任何参数时，函数默认join=’outer’。此方式是依照column来做纵向合并，有相同的column上下合并在一起，其他独自的column个自成列，原本没有值的位置皆以NaN填充。 1234567891011121314151617181920import pandas as pdimport numpy as np#定义资料集df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d','e'], index=[2,3,4])#纵向\"外\"合并df1与df2res = pd.concat([df1, df2], axis=0, join='outer')print(res)\"\"\" a b c d e1 0.0 0.0 0.0 0.0 NaN2 0.0 0.0 0.0 0.0 NaN3 0.0 0.0 0.0 0.0 NaN2 NaN 1.0 1.0 1.0 1.03 NaN 1.0 1.0 1.0 1.04 NaN 1.0 1.0 1.0 1.0\"\"\" 承上一个例子： 123456789101112131415161718192021222324252627#纵向\"内\"合并df1与df2res = pd.concat([df1, df2], axis=0, join='inner')#打印结果print(res)\"\"\" b c d1 0.0 0.0 0.02 0.0 0.0 0.03 0.0 0.0 0.02 1.0 1.0 1.03 1.0 1.0 1.04 1.0 1.0 1.0\"\"\"#重置index并打印结果res = pd.concat([df1, df2], axis=0, join='inner', ignore_index=True)print(res)\"\"\" b c d0 0.0 0.0 0.01 0.0 0.0 0.02 0.0 0.0 0.03 1.0 1.0 1.04 1.0 1.0 1.05 1.0 1.0 1.0\"\"\" join_axes(依照 axes 合并)123456789101112131415161718import pandas as pdimport numpy as np#定义数据集df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d','e'], index=[2,3,4])#依照`df1.index`进行横向合并res = pd.concat([df1, df2], axis=1, join_axes=[df1.index])#打印结果print(res)\"\"\"a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0\"\"\" append(添加数据)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pandas as pdimport numpy as np#定义数据集df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d','e'], index=[2,3,4])df3 = pd.DataFrame(np.ones((3,4))*2,columns=['a','b','c','d'])# 将df2合并到df1的下面，以及重置index，并打印出结果res = df1.append(df2,ignore_index=True)print(res)\"\"\" a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.0\"\"\"# 合并多个df，将df2与df3合并至df1的下面，以及重置index，并打印出结果res = df1.append([df2,df3],ignore_index=True)print(res)\"\"\" a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0\"\"\"# 合并series，将s1合并至df1，以及重置index，并打印出结果s1 = pd.Series([3,3,3,3],ignore_index+True)s1 = pd.Series([3,3,3,3],index=['a','b','c','d'])res = df1.append(s1,ignore_index=True)print(res)\"\"\" a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 3.0 3.0 3.0 3.0\"\"\" 七、合并mergepandas中的merge和concat类似,但主要是用于两组有key column的数据,统一索引的数据. 通常也被用在Database的处理当中。 依据一组key合并1234567891011121314151617181920212223242526272829303132333435363738import pandas as pd#定义资料集并打印出left = pd.DataFrame(&#123;'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']&#125;)right = pd.DataFrame(&#123;'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']&#125;)print(left)\"\"\"key1 key2 A B0 K0 K0 A0 B01 K0 K1 A1 B12 K1 K0 A2 B23 K2 K1 A3 B3\"\"\"print(right)\"\"\"key1 key2 C D0 K0 K0 C0 D01 K1 K0 C1 D12 K1 K0 C2 D23 K2 K0 C3 D3\"\"\"# 依据key column合并，并打印出res = pd.merge(left,right,on='key')print(res)\"\"\" key A B C D0 K0 A0 B0 C0 D01 K0 A1 B1 C0 D02 K1 A2 B2 C1 D13 K1 A2 B2 C2 D24 K2 A3 B3 C3 D3\"\"\" 依据两组key合并合并时有4种方法how = [‘left’, ‘right’, ‘outer’, ‘inner’]，预设值how=’inner’。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475left = pd.DataFrame(&#123;'key1': ['K0', 'K0', 'K1', 'K2'], 'key2': ['K0', 'K1', 'K0', 'K1'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']&#125;)right = pd.DataFrame(&#123;'key1': ['K0', 'K1', 'K1', 'K2'], 'key2': ['K0', 'K0', 'K0', 'K0'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']&#125;)left\"\"\" key1 key2 A B0 K0 K0 A0 B01 K0 K1 A1 B12 K1 K0 A2 B23 K2 K1 A3 B3\"\"\"right\"\"\" key1 key2 C D0 K0 K0 C0 D01 K1 K0 C1 D12 K1 K0 C2 D23 K2 K0 C3 D3\"\"\"res = pd.merge(left,right,on=['key1','key2'])res\"\"\" key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D2\"\"\"# 依据key1与key2 columns进行合并，并打印出四种结果['left', 'right', 'outer', 'inner']res = pd.merge(left,right,on=['key1','key2'],how='inner')res\"\"\" key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D2\"\"\"res = pd.merge(left,right,on=['key1','key2'],how='outer')res\"\"\" key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K0 K1 A1 B1 NaN NaN2 K1 K0 A2 B2 C1 D13 K1 K0 A2 B2 C2 D24 K2 K1 A3 B3 NaN NaN5 K2 K0 NaN NaN C3 D3\"\"\"res = pd.merge(left,right,on=['key1','key2'],how='right')res\"\"\" key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D23 K2 K0 NaN NaN C3 D3\"\"\"res = pd.merge(left,right,on=['key1','key2'],how='left')res\"\"\" key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K0 K1 A1 B1 NaN NaN2 K1 K0 A2 B2 C1 D13 K1 K0 A2 B2 C2 D24 K2 K1 A3 B3 NaN NaN\"\"\" Indicatorindicator=True会将合并的记录放在新的一列。 1234567891011121314151617181920212223242526272829303132333435363738df1 = pd.DataFrame(&#123;'col1':[0,1], 'col_left':['a','b']&#125;)df2 = pd.DataFrame(&#123;'col1':[1,2,2],'col_right':[2,2,2]&#125;)df1\"\"\" col1 col_left0 0 a1 1 b\"\"\"df2\"\"\" col1 col_right0 1 21 2 22 2 2\"\"\"# 依据col1进行合并，并启用indicator=True，最后打印出res = pd.merge(df1, df2, on='col1', how='outer', indicator=True)res\"\"\" col1 col_left col_right _merge0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only\"\"\"# 自定indicator column的名称，并打印出res = pd.merge(df1, df2, on='col1', how='outer', indicator='indicator_column')res\"\"\" col1 col_left col_right indicator_column0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only\"\"\" 依据index合并123456789101112131415161718192021222324252627282930313233343536373839404142left = pd.DataFrame(&#123;'A': ['A0', 'A1', 'A2'], 'B': ['B0', 'B1', 'B2']&#125;, index=['K0', 'K1', 'K2'])right = pd.DataFrame(&#123;'C': ['C0', 'C2', 'C3'], 'D': ['D0', 'D2', 'D3']&#125;, index=['K0', 'K2', 'K3'])left\"\"\" A BK0 A0 B0K1 A1 B1K2 A2 B2\"\"\"right\"\"\" C DK0 C0 D0K2 C2 D2K3 C3 D3\"\"\"# 依据左右资料集的index进行合并，how='outer',并打印出res = pd.merge(left, right, left_index=True, right_index=True, how='outer')res\"\"\" A B C DK0 A0 B0 C0 D0K1 A1 B1 NaN NaNK2 A2 B2 C2 D2K3 NaN NaN C3 D3\"\"\"# 依据左右资料集的index进行合并，how='inner',并打印出res = pd.merge(left, right, left_index=True, right_index=True, how='inner')res\"\"\" A B C DK0 A0 B0 C0 D0K2 A2 B2 C2 D2\"\"\" 解决overlapping的问题12345678910111213141516171819202122boys = pd.DataFrame(&#123;'k': ['K0', 'K1', 'K2'], 'age': [1, 2, 3]&#125;)girls = pd.DataFrame(&#123;'k': ['K0', 'K0', 'K3'], 'age': [4, 5, 6]&#125;)# 使用suffixes解决overlapping的问题，分清楚age来自哪个DataFrameres = pd.merge(boys, girls, on='k', suffixes=['_boy', '_girl'], how='inner')res\"\"\" k age_boy age_girl0 K0 1 41 K0 1 5\"\"\"res = pd.merge(boys, girls, on='k', suffixes=['_boy', '_girl'], how='outer')res\"\"\" k age_boy age_girl0 K0 1.0 4.01 K0 1.0 5.02 K1 2.0 NaN3 K2 3.0 NaN4 K3 NaN 6.0\"\"\" 八、plot出图创建一个Series这是一个线性的数据，我们随机生成1000个数据，Series 默认的 index 就是从0开始的整数，但是这里我显式赋值以便让大家看的更清楚 12345678910# 随机生成1000个数据data = pd.Series(np.random.randn(1000),index=np.arange(1000)) # 为了方便观看效果, 我们累加这个数据data.cumsum()# pandas 数据可以直接观看其可视化形式data.plot()plt.show() 就这么简单，熟悉 matplotlib 的朋友知道如果需要plot一个数据，我们可以使用 plt.plot(x=, y=)，把x,y的数据作为参数存进去，但是data本来就是一个数据，所以我们可以直接plot。 生成的结果就是下图： Dataframe 可视化我们生成一个1000*4 的DataFrame，并对他们累加 12345678data = pd.DataFrame( np.random.randn(1000,4), index=np.arange(1000), columns=list(\"ABCD\") )data.cumsum()data.plot()plt.show() 这个就是我们刚刚生成的4个column的数据，因为有4组数据，所以4组数据会分别plot出来。plot 可以指定很多参数，具体的用法大家可以自己查一下这里 除了plot，我经常会用到还有scatter，这个会显示散点图，首先给大家说一下在 pandas 中有多少种方法 bar hist box kde area scatter hexbin但是我们今天不会一一介绍，主要说一下 plot 和 scatter. 因为scatter只有x，y两个属性，我们我们就可以分别给x, y指定数据1ax = data.plot.scatter(x='A',y='B',color='DarkBlue',label='Class1') 然后我们在可以再画一个在同一个ax上面，选择不一样的数据列，不同的 color 和 label 123# 将之下这个 data 画在上一个 ax 上面data.plot.scatter(x='A',y='C',color='LightGreen',label='Class2',ax=ax)plt.show() 下面就是我plot出来的图片 本节参考自莫烦python，学习请点击：https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}],"author":"PalmLand"},{"title":"Python-04Numpy","slug":"python-04Numpy","date":"2019-07-14T01:28:06.000Z","updated":"2019-07-14T14:57:00.000Z","comments":true,"path":"2019/07/14/python-04Numpy/","link":"","permalink":"https://palmland.github.io/2019/07/14/python-04Numpy/","excerpt":"ndarray：一种多维数组对象 通用函数：快速的元素级数组函数 利用数组进行数据处理 用于数组的文件输入输出 线性代数 伪随机数生成 示例：随机漫步","text":"ndarray：一种多维数组对象 通用函数：快速的元素级数组函数 利用数组进行数据处理 用于数组的文件输入输出 线性代数 伪随机数生成 示例：随机漫步 NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。 NumPy的部分功能如下： ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。 线性代数、随机数生成以及傅里叶变换功能。 用于集成由C、C++、Fortran等语言编写的代码的A C API。 NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为： NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。 NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。 numpy可以高效处理大数组的数据 123456789import numpy as npmy_arr = np.arange(100000)my_list = list(range(100000))%time for _ in range(10): my_arr2 = my_arr *2# Wall time: 1 ms%time for _ in range(10): my_list2 = my_list *2# Wall time: 32.9 ms 一、NumPy的ndarray：一种多维数组对象NumPy最重要的一个特点就是其N维数组对象（即ndarray），是一个快速而灵活的大数据集容器。可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。 12345678910111213141516171819data = np.random.randn(2,3)data'''array([[ 0.5830263 , -0.39590117, 0.72400691], [ 0.83895026, -0.1634468 , -1.55589942]])'''# 进行数学运算：data*10'''array([[ 5.83026299, -3.95901173, 7.24006906], [ 8.38950264, -1.63446803, -15.5589942 ]])'''data+data'''array([[ 2.47469633, 0.01421658, 0.21865621], [ 3.72025764, -0.31933374, -0.8535659 ]])''' 每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）： 12345data.shape # (2,3)data.dtype # dtype('float64')data.ndim # 维度是2 创建ndarray创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例： 1234567891011data1 = [3,5.9,2,6]arr1 = np.array(data1)arr1 # array([3. , 5.9, 2. , 6. ])data2 = [[3,9,2,6],[29,4,3,16]]arr2 = np.array(data2)arr2 '''array([[ 3, 9, 2, 6], [29, 4, 3, 16]])''' 因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证： 123arr2.ndim # 2arr2.shape # (2, 4) np.array会尝试为新建的这个数组推断出一个较为合适的数据类型： 1arr2.dtype # dtype('int32') 除np.array之外，还有一些函数也可以新建数组。 zeros和ones分别可以创建指定长度或形状的全0或全1数组。 12np.zeros(10) # array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) empty可以创建一个没有任何具体值的数组。 12345np.empty((2,4))'''array([[0., 0., 0., 0.], [0., 0., 0., 0.]])''' 认为np.empty会返回全0数组的想法是不安全的，很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。 arange是Python内置函数range的数组版。 12345np.arange(15)'''array([[3, 3, 3, 3], [3, 3, 3, 3]])''' eye可以创建一个N*N的数组（对角线为1其余为0） 123456789np.eye(6)'''array([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]])''' full可以创建全部为指定值的数组 12345np.full((2,4),3)'''array([[3, 3, 3, 3], [3, 3, 3, 3]])''' ndarray的数据类型使用dtype指定数组数据类型： 12arr1 = np.array([1,2,3],dtype=np.float64)arr1.dtype # dtype('float64') Numpy的数据类型：可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype： 12345arr = np.array([1,2,3,4])arr.dtype # dtype('int32')float_arr = arr.astype(np.float64)float_arr.dtype # dtype('float64') 在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除： 12arr = np.array([1.7,20.6,0.93,4])arr.astype(np.int32) # array([ 1, 20, 0, 4]) 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式： 12numeric_strings = np.array(['1.24','6.99'],dtype=np.string_)numeric_strings.astype(float) # array([1.24, 6.99]) 如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。上面写的是float而不np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。 数组的dtype还有另一个属性，将一个数组类型转化成另一个数组的类型： 123int_array = np.arange(10)xx = np.array([.33,.24,.5])int_array.astype(xx.dtype) 你还可以用简洁的类型代码来表示dtype： 123456empty_uint32 = np.empty(8, dtype='u4')empty_uint32'''array([ 0, 1075314688, 0, 1075707904, 0, 1075838976, 0, 1072693248], dtype=uint32)''' 调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。 NumPy数组的运算大小相等的数组之间的任何算术运算都会将运算应用到元素级： 12345678910111213141516171819202122arr = np.array([[1., 2., 3.], [4., 5., 6.]])arr * arr '''array([[ 1., 4., 9.], [ 16., 25., 36.]])''' arr - arr'''array([[ 0., 0., 0.], [ 0., 0., 0.]])''' 1 / arr'''array([[ 1. , 0.5 , 0.3333], [ 0.25 , 0.2 , 0.1667]])''' arr ** 0.5'''array([[ 1. , 1.4142, 1.7321], [ 2. , 2.2361, 2.4495]])''' 大小相同的数组之间的比较会生成布尔值数组： 123456arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])arr2 &gt; arr'''array([[False, True, False], [ True, False, True]], dtype=bool)''' 基本的索引和切片1234arr = np.arange(10)arr[5:8] = 12arr # array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9]) 当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（广播）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。作为例子，先创建一个arr的切片： 123arr_slice = arr[5:8]arr_slice# array([12, 12, 12]) 切片[ : ]会给数组中的所有值赋值： 123arr_slice[:] = 64arr# array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9]) 如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如arr[5:8].copy()。 在一个二维数组中，各索引位置上的元素不再是标量而是一维数组： 123arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])arr2d[2]# array([7, 8, 9]) 访问单个元素，下面两种方式是等价的： 12arr2d[0][2] # 3arr2d[0, 2] # 3 切片索引1234arr# array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])arr[1:6]# array([ 1, 2, 3, 4, 64]) 对于之前的二维数组arr2d，其切片方式稍显不同： 12345678910111213141516171819202122arr2d '''array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'''arr2d[:2]'''array([[1, 2, 3], [4, 5, 6]])'''arr2d[:2, 1:]'''array([[2, 3], [5, 6]])'''arr2d[:, :1]'''array([[1], [4], [7]])''' 布尔型索引123456789101112names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])data = np.random.randn(7, 4)data'''array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.0072, -1.2962, 0.275 , 0.2289], [ 1.3529, 0.8864, -2.0016, -0.3718], [ 1.669 , -0.4386, -0.5397, 0.477 ], [ 3.2489, -1.0212, -0.5771, 0.1241], [ 0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])''' 我们想要选出对应于名字”Bob”的所有行： 12names == 'Bob'# array([ True, False, False, True, False, False, False], dtype=bool) 这个布尔型数组可用于数组索引： 12345data[names == 'Bob']'''array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.669 , -0.4386, -0.5397, 0.477 ]])''' 下面的例子，我选取了names == &#39;Bob&#39;的行，并索引了列： 12345data[names == 'Bob', 2:]'''array([[ 0.769 , 1.2464], [-0.5397, 0.477 ]])''' ~操作符用来反转条件很好用： 123456789cond = names == 'Bob'data[~cond]'''array([[ 1.0072, -1.2962, 0.275 , 0.2289], [ 1.3529, 0.8864, -2.0016, -0.3718], [ 3.2489, -1.0212, -0.5771, 0.1241], [ 0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])''' 选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可： 123mask = (names == 'Bob') | (names == 'Will')mask# array([ True, False, True, True, True, False, False], dtype=bool) 通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。 通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需： 1234567891011data[data &lt; 0] = 0data'''array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.0072, 0. , 0.275 , 0.2289], [ 1.3529, 0.8864, 0. , 0. ], [ 1.669 , 0. , 0. , 0.477 ], [ 3.2489, 0. , 0. , 0.1241], [ 0.3026, 0.5238, 0.0009, 1.3438], [ 0. , 0. , 0. , 0. ]])''' 花式索引花式索引指的是利用整数数组进行索引。假设我们有一个8×4数组： 1234567891011121314arr = np.empty((8, 4))for i in range(8): arr[i] = iarr'''array([[ 0., 0., 0., 0.], [ 1., 1., 1., 1.], [ 2., 2., 2., 2.], [ 3., 3., 3., 3.], [ 4., 4., 4., 4.], [ 5., 5., 5., 5.], [ 6., 6., 6., 6.], [ 7., 7., 7., 7.]])''' 为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可： 1234567arr[[4, 3, 0, 6]] '''array([[ 4., 4., 4., 4.], [ 3., 3., 3., 3.], [ 0., 0., 0., 0.], [ 6., 6., 6., 6.]])''' 一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组： 1234567891011121314arr = np.arange(32).reshape((8, 4))arr'''array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]])'''arr[[1, 5, 7, 2], [0, 3, 1, 2]]# array([ 4, 23, 29, 10]) 1234567arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]'''array([[ 4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [ 8, 11, 9, 10]])''' 花式索引跟切片不一样，它总是将数据复制到新数组中。 数组转置和轴对换123456789101112131415arr = np.arange(15).reshape((3, 5))arr'''array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])'''arr.T'''array([[ 0, 5, 10], [ 1, 6, 11], [ 2, 7, 12], [ 3, 8, 13], [ 4, 9, 14]])''' 利用np.dot计算矩阵内积： 12345678910111213141516arr = np.random.randn(6, 3)arr''' array([[-0.8608, 0.5601, -1.2659], [ 0.1198, -1.0635, 0.3329], [-2.3594, -0.1995, -1.542 ], [-0.9707, -1.307 , 0.2863], [ 0.378 , -0.7539, 0.3313], [ 1.3497, 0.0699, 0.2467]])'''np.dot(arr.T, arr)'''array([[ 9.2291, 0.9394, 4.948 ], [ 0.9394, 3.7662, -1.3622], [ 4.948 , -1.3622, 4.3437]])''' 对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置： 12345678910111213141516arr = np.arange(16).reshape((2, 2, 4))arr'''array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]])'''arr.transpose((1, 0, 2))'''array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]])''' 这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。ndarray还有一个swapaxes方法，它需要接受一对轴编号： 123456789101112131415161718arr''' array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]])'''arr.swapaxes(1, 2)'''array([[[ 0, 4], [ 1, 5], [ 2, 6], [ 3, 7]], [[ 8, 12], [ 9, 13], [10, 14], [11, 15]]])''' swapaxes也是返回源数据的视图（不会进行任何复制操作）。 二、通用函数：快速的元素级数组函数通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。以下是一元（unary）ufunc： 123456789101112131415arr = np.arange(10)arr# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])np.sqrt(arr)'''array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495, 2.6458, 2.8284, 3. ])'''np.exp(arr)'''array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982, 148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])''' 另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组： 1234567891011x = np.random.randn(8)y = np.random.randn(8)x# array([-0.0119, 1.0048, 1.3272, -0.9193, -1.5491, 0.0222, 0.7584, -0.6605])y# array([ 0.8626, -0.01 , 0.05 , 0.6702, 0.853 , -0.9559, -0.0235, -2.3042]) np.maximum(x, y)# array([ 0.8626, 1.0048, 1.3272, 0.6702, 0.853 , 0.0222, 0.7584, -0.6605]) 有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分： 123456789101112arr = np.random.randn(7) * 5arr# array([-3.2623, -6.0915, -6.663 , 5.3731, 3.6182, 3.45 , 5.0077])remainder, whole_part = np.modf(arr)remainder# array([-0.2623, -0.0915, -0.663 , 0.3731, 0.6182, 0.45 , 0.0077])whole_part# array([-3., -6., -6., 5., 3., 3., 5.]) Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作： 1234567891011arr# array([-3.2623, -6.0915, -6.663 , 5.3731, 3.6182, 3.45 , 5.0077])np.sqrt(arr)# array([ nan, nan, nan, 2.318 , 1.9022, 1.8574, 2.2378])np.sqrt(arr, arr)# array([ nan, nan, nan, 2.318 , 1.9022, 1.8574, 2.2378])arr# array([ nan, nan, nan, 2.318 , 1.9022, 1.8574, 2.2378]) 下面两个表分别列出了一些一元和二元ufunc。 三、利用数组进行数据处理假设我们想要在一组值（网格型）上计算函数sqrt(x^2+y^2)。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）： 123456789101112points = np.arange(-5, 5, 0.01) # 1000 equally spaced pointsxs, ys = np.meshgrid(points, points)ys''' array([[-5. , -5. , -5. , ..., -5. , -5. , -5. ], [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99], [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98], ..., [ 4.97, 4.97, 4.97, ..., 4.97, 4.97, 4.97], [ 4.98, 4.98, 4.98, ..., 4.98, 4.98, 4.98], [ 4.99, 4.99, 4.99, ..., 4.99, 4.99, 4.99]])''' 对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可： 123456789101112z = np.sqrt(xs ** 2 + ys ** 2)z''' array([[ 7.0711, 7.064 , 7.0569, ..., 7.0499, 7.0569, 7.064 ], [ 7.064 , 7.0569, 7.0499, ..., 7.0428, 7.0499, 7.0569], [ 7.0569, 7.0499, 7.0428, ..., 7.0357, 7.0428, 7.0499], ..., [ 7.0499, 7.0428, 7.0357, ..., 7.0286, 7.0357, 7.0428], [ 7.0569, 7.0499, 7.0428, ..., 7.0357, 7.0428, 7.0499], [ 7.064 , 7.0569, 7.0499, ..., 7.0428, 7.0499, 7.0569]])''' 用matplotlib创建了这个二维数组的可视化： 123456import matplotlib.pyplot as pltplt.imshow(z, cmap=plt.cm.gray); plt.colorbar()# &lt;matplotlib.colorbar.Colorbar at 0x7f715e3fa630&gt;plt.title(\"Image plot of $\\sqrt&#123;x^2 + y^2&#125;$ for a grid of values\")# &lt;matplotlib.text.Text at 0x7f715d2de748&gt; 将条件逻辑表述为数组运算假设我们有一个布尔数组和两个值数组： 12345xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])cond = np.array([True, False, True, True, False]) 假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示： 12345result = [(x if c else y) .....: for x, y, c in zip(xarr, yarr, cond)]result# [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5] 这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁，numpy.where函数是三元表达式x if condition else y的矢量化版本。 1234result = np.where(cond, xarr, yarr)resultarray([ 1.1, 2.2, 1.3, 1.4, 2.5]) np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。 假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单： 123456789101112131415arr = np.random.randn(4, 4)arr'''array([[-0.5031, -0.6223, -0.9212, -0.7262], [ 0.2229, 0.0513, -1.1577, 0.8167], [ 0.4336, 1.0107, 1.8249, -0.9975], [ 0.8506, -0.1316, 0.9124, 0.1882]])'''np.where(arr &gt; 0, 2, -2)'''array([[-2, -2, -2, -2], [ 2, 2, -2, 2], [ 2, 2, 2, -2], [ 2, -2, 2, 2]])''' 传递给where的数组大小可以不相等，甚至可以是标量值。 数学和统计方法可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。 12345678910111213141516arr = np.random.randn(5, 4)arr.mean()# 0.19607051119998253np.mean(arr)# 0.19607051119998253arr.sum()# 3.9214102239996507arr.mean(axis=1)# array([ 1.022 , 0.1875, -0.502 , -0.0881, 0.3611])arr.sum(axis=0)# array([ 3.1693, -2.6345, 2.2381, 1.1486]) arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。 累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类： 1234567891011121314151617181920212223242526272829arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])arr'''array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])'''# 列累加arr.cumsum(axis=0)''' array([[ 0, 1, 2], [ 3, 5, 7], [ 9, 12, 15]])'''# 行累加arr.cumsum(axis=1)''' array([[ 0, 1, 3], [ 3, 7, 12], [ 6, 13, 21]])'''# 行累乘arr.cumprod(axis=1)''' array([[ 0, 0, 0], [ 3, 12, 60], [ 6, 42, 336]])''' 下表列出了全部的基本数组统计方法。 用于布尔型数组的方法sum经常被用来对布尔型数组中的True值计数： 1234arr = np.random.randn(100)(arr &gt; 0).sum() # Number of positive values# 42 any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True： 123bools = np.array([False, False, True, False])bools.any() # Truebools.all() # False 这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。 排序1234567arr = np.random.randn(6)arr# array([ 0.6095, -0.4938, 1.24 , -0.1357, 1.43 , -0.8469])arr.sort()# 多维数组也可以arr# array([-0.8469, -0.4938, -0.1357, 0.6095, 1.24 , 1.43 ]) 多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可： 12345678910111213141516171819arr = np.random.randn(5, 3)arr'''array([[ 0.6033, 1.2636, -0.2555], [-0.4457, 0.4684, -0.9616], [-1.8245, 0.6254, 1.0229], [ 1.1074, 0.0909, -0.3501], [ 0.218 , -0.8948, -1.7415]])'''arr.sort(1) # 按行排列arr'''array([[-0.2555, 0.6033, 1.2636], [-0.9616, -0.4457, 0.4684], [-1.8245, 0.6254, 1.0229], [-0.3501, 0.0909, 1.1074], [-1.7415, -0.8948, 0.218 ]])''' 唯一化以及其它的集合逻辑最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果： 123456789names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])np.unique(names)# array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])np.unique(ints)# array([1, 2, 3, 4]) 拿跟np.unique等价的纯Python代码来对比一下： 12sorted(set(names))# ['Bob', 'Joe', 'Will'] 另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组： 1234values = np.array([6, 0, 0, 3, 2, 5, 6])np.in1d(values, [2, 3, 6])# array([ True, False, False, True, True, False, True], dtype=bool) np.intersect1d计算x,y的公共元素： 12np.intersect1d([1, 2, 4], [2, 4, 5])# array([2, 4]) 四、用于数组的文件输入输出np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的： 12arr = np.arange(10)np.save('some_array', arr) 通过np.load读取磁盘上的数组： 12np.load('some_array.npy')# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可： 1np.savez('array_archive.npz', a=arr, b=arr) 加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载： 1234arch = np.load('array_archive.npz')arch['b']# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 如果要将数据压缩，可以使用numpy.savez_compressed： np.savez_compressed('arrays_compressed.npz', a1234567891011```# 五、线性代数NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：```pythonx = np.array([[1., 2., 3.], [4., 5., 6.]])y = np.array([[6., 23.], [-1, 7], [8, 9]])x.dot(y)'''array([[ 28., 64.], [ 67., 181.]])''' x.dot(y)等价于np.dot(x, y)： 12345np.dot(x, y)''' array([[ 28., 64.], [ 67., 181.]])''' @符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法： 1x @ np.ones(3) # array([ 6., 15.]) numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。 12345678910111213141516171819202122232425262728from numpy.linalg import inv, qrX = np.random.randn(5, 5)mat = X.T.dot(X)inv(mat)'''array([[ 933.1189, 871.8258, -1417.6902, -1460.4005, 1782.1391], [ 871.8258, 815.3929, -1325.9965, -1365.9242, 1666.9347], [-1417.6902, -1325.9965, 2158.4424, 2222.0191, -2711.6822], [-1460.4005, -1365.9242, 2222.0191, 2289.0575, -2793.422 ], [ 1782.1391, 1666.9347, -2711.6822, -2793.422 , 3409.5128]])'''mat.dot(inv(mat))'''array([[ 1., 0., -0., -0., -0.], [-0., 1., 0., 0., 0.], [ 0., 0., 1., 0., 0.], [-0., 0., 0., 1., -0.], [-0., 0., 0., 0., 1.]])'''q, r = qr(mat)r'''array([[-1.6914, 4.38 , 0.1757, 0.4075, -0.7838], [ 0. , -2.6436, 0.1939, -3.072 , -1.0702], [ 0. , 0. , -0.8138, 1.5414, 0.6155], [ 0. , 0. , 0. , -2.6445, -2.1669], [ 0. , 0. , 0. , 0. , 0.0002]])''' 下表列出了一些最常用的线性代数函数。 六、伪随机数生成numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。 例如，你可以用normal来得到一个标准正态分布的4×4样本数组： 123456789samples = np.random.normal(size=(4, 4))samples'''array([[ 0.5732, 0.1933, 0.4429, 1.2796], [ 0.575 , 0.4339, -0.7658, -1.237 ], [-0.5367, 1.8545, -0.92 , -0.1082], [ 0.1525, 0.9435, -1.0953, -0.144 ]])''' 而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级： 123456789from random import normalvariateN = 1000000%timeit samples = [normalvariate(0, 1) for _ in range(N)]# 1.77 s +- 126 ms per loop (mean +- std. dev. of 7 runs, 1 loop each)%timeit np.random.normal(size=N)# 61.7 ms +- 1.32 ms per loop (mean +- std. dev. of 7 runs, 10 loops each) 这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子： 1np.random.seed(1234) numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器： 1234567rng = np.random.RandomState(1234)rng.randn(10)''' array([ 0.4714, -1.191 , 1.4327, -0.3127, -0.7206, 0.8872, 0.8596, -0.6365, 0.0157, -2.2427])''' 下表列出了numpy.random中的部分函数。 七、示例：随机漫步我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。 12345678import random .....: position = 0 .....: walk = [position] .....: steps = 1000 .....: for i in range(steps): .....: step = 1 if random.randint(0, 1) else -1 .....: position += step .....: walk.append(position) 下图根据前100个随机漫步值生成的折线图： 1plt.plot(walk[:100]) 我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和： 12345678nsteps = 1000draws = np.random.randint(0, 2, size=nsteps)steps = np.where(draws &gt; 0, 1, -1)walk = steps.cumsum()walk.min() # -3walk.max() # 31 假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）： 1(np.abs(walk) &gt;= 10).argmax() # 37 一次模拟多个随机漫步如果你希望模拟多个随机漫步过程（比如5000个），只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了： 123456789101112131415nsteps = 1000draws = np.random.randint(0,2,size=(nwalks,nsteps))steps = np.where(draws&gt;0,1,-1)walk = steps.cumsum(1)'''array([[ 1, 0, 1, ..., 8, 7, 8], [ 1, 0, -1, ..., 34, 33, 32], [ 1, 0, -1, ..., 4, 5, 4], ..., [ 1, 2, 1, ..., 24, 25, 26], [ 1, 2, 3, ..., 14, 13, 14], [ -1, -2, -3, ..., -24, -23, -22]])'''walk.max() # 138walk.min() # -133 计算30或－30的最小穿越时间，不是5000个过程都到达了30，用any方法来对此进行检查： 123hits30=(np.abs(walk)&gt;=30).any(1)hits30.sum() # Number that hit 30 or -30# 3410 这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间： 12crossing_times = (np.abs(walk[hits30]) &gt;= 30).argmax(1)crossing_times.mean() # 498.88973607038122 用其他分布方式得到漫步数据，比如normal用于生成指定均值和标准差的正态分布数据： 12345steps = np.random.normal(loc=0,scale=0.25,size=(nwalks,nsteps))walk = steps.cumsum(1)hits30=(np.abs(walk)&gt;=30).any(1)crossing_times = (np.abs(walk[hits30]) &gt;= 30).argmax(1)crossing_times.mean() # 999.0 本节参考自《利用python进行数据分析》第四章，阅读链接：https://wizardforcel.gitbooks.io/pyda-2e/content/4.html","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}]},{"title":"Python-03高级特性","slug":"python-03高级特性","date":"2019-07-11T10:03:00.000Z","updated":"2019-08-12T12:44:15.363Z","comments":true,"path":"2019/07/11/python-03高级特性/","link":"","permalink":"https://palmland.github.io/2019/07/11/python-03高级特性/","excerpt":"切片 迭代 列表生成式 生成器 迭代器","text":"切片 迭代 列表生成式 生成器 迭代器 这一节介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。 一、切片一个list如下： 1L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 或者取前N个元素，也就是索引为0-(N-1)的元素，可以用循环。 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 1234&gt;&gt;&gt; L[-2:][&apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; L[-2:-1][&apos;Bob&apos;] 切片操作十分有用。我们先创建一个0-99的数列： 123&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如后10个数： 12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前10个数，每两个取一个： 12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 甚至什么都不写，只写[:]就可以原样复制一个list： 12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： 12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 1234&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 练习利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法： 1234567891011121314151617181920212223242526272829303132333435363738def trim(s): if n == &apos;&apos; return s else: n = 0 m = len(s) while s[n] == &apos; &apos; and n &lt; m-1: n += 1 while s[m-1] == &apos; &apos; and m &gt; n: m -= 1 return s[n:m]# 或者&apos;&apos;&apos;def trim(s): if len(s) != 0: while s[:1] == &apos; &apos;: s = s[1:] while s[-1:] == &apos; &apos;: s = s[:-1] return s&apos;&apos;&apos;# 测试:if trim(&apos;hello &apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello&apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello &apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello world &apos;) != &apos;hello world&apos;: print(&apos;测试失败!&apos;)elif trim(&apos;&apos;) != &apos;&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; &apos;) != &apos;&apos;: print(&apos;测试失败!&apos;)else: print(&apos;测试成功!&apos;) 小结有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。 二、迭代如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过for … in来完成的。Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。比如dict就可以迭代： 123456&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; for key in d: print(key)acb 默认情况下，dict迭代的是key; 如果要迭代value，可以用for value in d.values(); 如果要同时迭代key和value，可以用for k, v in d.items()。 那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 123456&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print(i, value)...0 A1 B2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 练习请使用迭代查找一个list中最小和最大值，并返回一个tuple： 123456789101112131415161718def findMinAndMax(L): if L == []: return(None,None) else: return(min(L),max(L))# 测试if findMinAndMax([]) != (None, None): print(&apos;测试失败!&apos;)elif findMinAndMax([7]) != (7, 7): print(&apos;测试失败!&apos;)elif findMinAndMax([7, 1]) != (1, 7): print(&apos;测试失败!&apos;)elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9): print(&apos;测试失败!&apos;)else: print(&apos;测试成功!&apos;) 三、列表生成式列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式。举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))： 1list(range(1,11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： 12&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;][&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 三层和三层以上的循环就很少用到了。 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： 123&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 列表生成式也可以使用两个变量来生成list： 123&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()][&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： 123&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]&gt;&gt;&gt; [s.lower() for s in L][&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 练习如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错： 123456&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]&gt;&gt;&gt; [s.lower() for s in L]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;listcomp&gt;AttributeError: &apos;int&apos; object has no attribute &apos;lower&apos; 使用内建的isinstance函数可以判断一个变量是不是字符串： 123456&gt;&gt;&gt; x = &apos;abc&apos;&gt;&gt;&gt; y = 123&gt;&gt;&gt; isinstance(x, str)True&gt;&gt;&gt; isinstance(y, str)False 请修改列表生成式，通过添加if语句保证列表生成式能正确地执行： 12345678910L1 = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]L2 = [s.lower() for s in L1 if isinstance(s, str)]# 测试:print(L2)if L2 == [&apos;hello&apos;, &apos;world&apos;, &apos;apple&apos;]: print(&apos;测试通过!&apos;)else: print(&apos;测试失败!&apos;)# 测试通过! 四、生成器通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 创建一个generator有很多种方法。 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 我们怎么打印出generator的每一个元素呢？如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值： 123456789101112131415161718192021222324&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 但上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象： 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)... 0149162536496481 generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 第二种方法是使用关键字yield 比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：1, 1, 2, 3, 5, 8, 13, 21, 34, … 斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return &apos;done&apos; 仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &apos;done&apos; 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator： 123&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 举个简单的例子，定义一个generator，依次返回数字1，3，5： 1234567def odd(): print(&apos;step 1&apos;) yield(1) print(&apos;step 2&apos;) yield(3) print(&apos;step 3&apos;) yield(5) 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值： 1234567891011121314&gt;&gt;&gt; o = odd()&gt;&gt;&gt; next(o)step 11&gt;&gt;&gt; next(o)step 23&gt;&gt;&gt; next(o)step 35&gt;&gt;&gt; next(o)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。 回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。 同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代： 123456789&gt;&gt;&gt; for n in fib(6):... print(n)...112358 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 12345678910111213141516&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print(&apos;g:&apos;, x)... except StopIteration as e:... print(&apos;Generator return value:&apos;, e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 练习杨辉三角定义如下： 1234567891011 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 把每一行看做一个list，试写一个generator，不断输出下一行的list： 123456789101112131415161718192021222324252627282930313233343536373839404142def triangles(): L = [1] yield L while True: L=[1]+[L[x]+L[x+1] for x in range(len(L)-1)]+[1] yield L# 期待输出:# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 10: break if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print(&apos;测试通过!&apos;)else: print(&apos;测试失败!&apos;) 小结在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。 要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。 请注意区分普通函数和generator函数，普通函数调用直接返回结果： 123&gt;&gt;&gt; r = abs(6)&gt;&gt;&gt; r6 generator函数的“调用”实际返回一个generator对象： 123&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; g&lt;generator object fib at 0x1022ef948&gt; 五、迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 集合数据类型，如list、tuple、dict、set、str等； generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象： 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False 生成器generator都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 小结凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如： 1234567891011121314for x in [1, 2, 3, 4, 5]: pass实际上完全等价于：# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}],"author":"PalmLand"},{"title":"Python-02函数","slug":"python-02函数","date":"2019-05-26T03:35:37.000Z","updated":"2019-05-27T11:05:46.000Z","comments":true,"path":"2019/05/26/python-02函数/","link":"","permalink":"https://palmland.github.io/2019/05/26/python-02函数/","excerpt":"调用函数 定义函数 函数的参数 递归函数","text":"调用函数 定义函数 函数的参数 递归函数 一、调用函数Python内置了很多有用的函数，可以直接调用。https://docs.python.org/3/library/functions.html比如求绝对值的函数abs，只有一个参数，可以在交互式命令行通过help(abs)查看abs函数的帮助信息。 12345help(abs)Help on built-in function abs in module builtins:abs(x, /) Return the absolute value of the argument. 调用abs函数： 1abs(-20) # 20 数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： 123int(&apos;123&apos;) # 123int(12.34) # 12bool(&apos;&apos;) # False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 12a = abs # 变量a指向abs函数a(-1) # 所以也可以通过a调用abs函数,返回1 练习利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串 12n1 = 255hex(n1) # &apos;0xff&apos; 二、定义函数以自定义一个求绝对值的my_abs函数为例： 123456def my_abs(x): if x &gt;= 0: return x else: return -xprint(my_abs(-99)) # 99 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数: 12from abstest import my_abs my_abs(-9) # 9 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass 实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 pass还可以用在其他语句里，比如： 12if age &gt;= 18: pass 缺少了pass，代码运行就会有语法错误。 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError： 1234&gt;&gt;&gt; my_abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: my_abs() takes 1 positional argument but 2 were given 但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别： 123456789&gt;&gt;&gt; my_abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in my_absTypeError: unorderable types: str() &gt;= int()&gt;&gt;&gt; abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。 修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError(&apos;bad operand type&apos;) if x &gt;= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误： 12345&gt;&gt;&gt; my_abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in my_absTypeError: bad operand type 返回多个值比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 然后，我们就可以同时获得返回值： 12x, y = move(100, 100, 60, math.pi / 6)print(x, y) # 151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 12r = move(100, 100, 60, math.pi / 6)print(r) # (151.96152422706632, 70.0) 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 小结定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 练习定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的两个解。提示：使用一元二次方程的求根公式 123456789101112131415161718import mathdef quadratic(a, b, c): x1 = (-b + math.sqrt(b*b-4*a*c))/(2*a) x2 = (-b - math.sqrt(b*b-4*a*c))/(2*a) return x1,x2x1, x2 = quadratic(1, 5, 6)print(x1, x2) # -2.0 -3.0# 测试:print(&apos;quadratic(2, 3, 1) =&apos;, quadratic(2, 3, 1)) # quadratic(2, 3, 1) = (-0.5, -1.0)print(&apos;quadratic(1, 3, -4) =&apos;, quadratic(1, 3, -4)) # quadratic(1, 3, -4) = (1.0, -4.0)if quadratic(2, 3, 1) != (-0.5, -1.0): print(&apos;测试失败&apos;)elif quadratic(1, 3, -4) != (1.0, -4.0): print(&apos;测试失败&apos;)else: print(&apos;测试成功&apos;) # 测试成功 三、函数的参数除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数我们先写一个计算$x^2$的函数： 12def power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。 当我们调用power函数时，必须传入有且仅有的一个参数x 1power(5) # 25 现在，如果我们要计算$x^3$怎么办？可以再定义一个power3函数，但是如果要计算$x^4$、$x^5$……怎么办？我们不可能定义无限多个函数。 可以把power(x)修改为power(x, n)，用来计算$x^n$： 1234567def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5, 2) # 25 修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 默认参数新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用： 1234&gt;&gt;&gt; power(5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: &apos;n&apos; Python的错误信息很明确：调用函数power()缺少了一个位置参数n。 这个时候，默认参数就排上用场了。由于我们经常计算$x^2$，所以，完全可以把第二个参数n的默认值设定为2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样，当我们调用power(5)时，相当于调用power(5, 2)： 12power(5) # 25power(5, 2) # 25 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 使用默认参数有什么好处？最大的好处是能降低调用函数的难。 可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算$a^2 + b^2 + c^2 + ……$。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 12calc([1, 2, 3]) # 14calc((1, 3, 5, 7)) # 84 我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 利用可变参数，调用函数的方式可以简化成这样： 123calc(1, 2, 3) # 14calc(1, 3, 5, 7) # 84calc() # 0 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： 12nums = [1, 2, 3]calc(nums[0], nums[1], nums[2]) # 14 这种写法太繁琐，Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： 12nums = [1, 2, 3]calc(*nums) # 14 *nums表示把nums这个list的所有元素作为可变参数传进去。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 12def person(name, age, **kw): print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 1person(&apos;Michael&apos;, 30) # name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 关键字参数有什么用？它可以扩展函数的功能。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 当然，上面复杂的调用可以用简化的写法： 123extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;person(&apos;Jack&apos;, 24, **extra)# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数： 12345678def person(name, age, **kw): if &apos;city&apos; in kw: # 有city参数 pass if &apos;job&apos; in kw: # 有job参数 pass print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 但调用者仍可以传入不受限制的关键字参数： 12person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, addr=&apos;Chaoyang&apos;, zipcode=123456)# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;addr&apos;: &apos;Chaoyang&apos;, &apos;zipcode&apos;: 123456&#125; 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数*kw不同，命名关键字参数需要一个特殊分隔符，*后面的参数(city, job)被视为命名关键字参数。 调用方式如下： 12person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)# Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： 12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错： 1234&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。若改为： 12person(&apos;Jack&apos;, 24, city = &apos;Beijing&apos;, job = &apos;Engineer&apos;)# Jack 24 () Beijing Engineer 则没错。命名关键字参数可以有缺省值，从而简化调用： 12def person(name, age, *, city=&apos;Beijing&apos;, job): print(name, age, city, job) 由于命名关键字参数city具有默认值，调用时，可不传入city参数： 12person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)# Jack 24 Beijing Engineer 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个作为特殊分隔符。如果缺少，Python解释器将无法识别位置参数和命名关键字参数： 123def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。比如定义一个函数，包含上述若干种参数： 12345def f1(a, b, c=0, *args, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)def f2(a, b, c=0, *, d, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw) 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数： 12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125; 所以，对于任意函数，都可以通过类似func(args, *kw)的形式调用它，无论它的参数是如何定义的。 练习接收一个或多个数并计算乘积： 123456789101112131415161718192021222324252627def product(*numbers): sum = 1 if len(numbers) == 0: raise TypeError(&apos;参数不能为空, 否则没有意义!&apos;) else: for n in numbers: sum = sum * n return sumprint(&apos;product(5) =&apos;, product(5))print(&apos;product(5, 6) =&apos;, product(5, 6))print(&apos;product(5, 6, 7) =&apos;, product(5, 6, 7))print(&apos;product(5, 6, 7, 9) =&apos;, product(5, 6, 7, 9))if product(5) != 5: print(&apos;测试1失败!&apos;)elif product(5, 6) != 30: print(&apos;测试2失败!&apos;)elif product(5, 6, 7) != 210: print(&apos;测试3失败!&apos;)elif product(5, 6, 7, 9) != 1890: print(&apos;测试4失败!&apos;)else: try: product() print(&apos;测试5失败!&apos;) except TypeError: print(&apos;测试6成功!&apos;)product() 1234567product(5) = 5product(5, 6) = 30product(5, 6, 7) = 210product(5, 6, 7, 9) = 1890测试6成功! 小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 四、递归函数如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘$n! = 1 x 2 x 3 x … x n$，用函数fact(n)表示，可以看出： fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n 所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 12&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： 1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 4, in fact ... File &quot;&lt;stdin&gt;&quot;, line 4, in factRuntimeError: maximum recursion depth exceeded in comparison 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。 fact(5)对应的fact_iter(5, 1)的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。 小结使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。 练习汉诺塔的移动可以用递归函数非常简单地实现。 编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如： 1234567891011def move(n, a, b, c): if n == 1: print(a,&apos;--&gt;&apos;,c) else: # 先将a柱子上的（前）N-1个圆盘借助c移动到柱子b上； move(n-1,a, c, b) # 再把a上最后的大圆盘挪动到c上 move(1,a, b, c) # 最后把b上的n-1个圆盘挪动到c上 move(n-1,b, a, c)move(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;) 结果： 1234567# A --&gt; C# A --&gt; B# C --&gt; B# A --&gt; C# B --&gt; A# B --&gt; C# A --&gt; C 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017105145133280","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}]},{"title":"Python-01基础","slug":"python-01基础","date":"2019-05-24T02:44:59.000Z","updated":"2019-06-04T01:28:06.000Z","comments":true,"path":"2019/05/24/python-01基础/","link":"","permalink":"https://palmland.github.io/2019/05/24/python-01基础/","excerpt":"数据类型和变量 字符串和编码 list和tuple 条件判断 循环 dict和set","text":"数据类型和变量 字符串和编码 list和tuple 条件判断 循环 dict和set 一、数据类型和变量在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数。对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 1print('I\\'m \\\"OK\\\"!') # I'm \"OK\"! \\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\ 123456print('\\\\\\n\\\\')'''输出：\\\\''' 为了简化，Python还允许用r’’表示’’内部的字符串默认不转义 12345678910print('\\\\\\t\\\\') '''输出：\\ \\'''print(r'\\\\\\t\\\\')'''输出：\\\\\\t\\\\''' Python允许用’’’…’’’的格式表示多行内容 123456789print('''line1line2line3''')'''输出：line1line2line3''' 布尔值一个布尔值只有True、False两种值，要么是True，要么是False。 13 &gt; 2 # True 布尔值可以用and、or和not运算。 123456True and True # TrueTrue or False # TrueFalse or False # False5 &gt; 3 or 1 &gt; 3 # Truenot True # Falsenot 1 &gt; 2 # True 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如： 1a = 1 # 变量a是一个整数 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print(a) # 123a = 'ABC' # a变为字符串print(a) # ABC 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下： 12int a = 123; // a是整数类型变量a = \"ABC\"; // 错误：不能把字符串赋给整型变量 理解变量在计算机内存中的表示也非常重要。当我们写： 1a = 'ABC' 时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = 'ABC'b = aa = 'XYZ'print(b) 1.执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’; 2.执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’; 3.执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改。 所以，最后打印变量b的结果自然是’ABC’了。 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量： 1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 110 / 3 # 3.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 19 / 3 # 3.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 110 // 3 # 3 整数的地板除//永远是整数，即使除不尽。 Python还提供一个余数运算，可以得到两个整数相除的余数： 110 % 3 # 1 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 练习请打印出以下变量的值： 123456789101112131415n = 123f = 456.789s1 = 'Hello, world's2 = 'Hello, \\'Adam\\''s3 = r'Hello, \"Bart\"'s4 = r'''Hello,Lisa!'''print(n) # 123print(f) # 456.789print(s1) # Hello, worldprint(s2) # Hello, 'Adam'print(s3) # Hello, \"Bart\"print(s4) Hello,Lisa! 小结Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。 注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。 Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 二、字符串和编码字符编码字符串比较特殊的是有一个编码问题。 全世界有上百种语言，中国制定了GB2312编码，用来把中文编进去，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码。 Python的字符串在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如： 1print('包含中文的str') # 包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 1234ord('A') # 65ord('中') # 20013chr(66) # 'B'chr(25991) # '文' 如果知道字符的整数编码，还可以用十六进制这么写str： 1'\\u4e2d\\u6587' # '中文' 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b'ABC' 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678'ABC'.encode('ascii') # b'ABC''中文'.encode('utf-8') # b'\\xe4\\xb8\\xad\\xe6\\x96\\x87''中文'.encode('ascii') '''Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)''' 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 12b'ABC'.decode('ascii') # 'ABC'b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8') # '中文' 如果bytes中包含无法解码的字节，decode()方法会报错： 123456b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')'''Traceback (most recent call last): ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte''' 如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节： 1b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore') # '中' 要计算str包含多少个字符，可以用len()函数： 12len('ABC') # 3len('中文') # 2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123len(b'ABC') # 3len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87') # 6len('中文'.encode('utf-8')) # 6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。 如果.py文件本身使用UTF-8编码，并且也申明了# -- coding: utf-8 --，打开命令提示符测试就可以正常显示中文。 格式化最后一个常见的问题是如何输出格式化的字符串。 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 12345'Hello, %s' % 'world' # 'Hello, world''Hi, %s, you have $%d.' % ('Michael', 1000000) # 'Hi, Michael, you have $1000000.' %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12print('%02d-%02d' % (3, 1)) # 03-01print('%.2f' % 3.1415926) # 3.14 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： 12'Age: %s. Gender: %s' % (25, True) # 'Age: 25. Gender: True' 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个% 12'growth rate: %d %%' % 7' # growth rate: 7 %' 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125) # 'Hello, 小明, 成绩提升了 17.1%' 练习小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出’xx.x%’，只保留小数点后1位： 123456s1 = 72s2 = 85r = (s2-s1)/s1r = r*100print('%.1f%%' % r)# 18.1% 小结Python 3的字符串使用Unicode，直接支持多语言。 当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312： 12'中文'.encode('gb2312')# b'\\xd6\\xd0\\xce\\xc4' 但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。 格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。 三、使用list和tuplelistlist是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 123classmates = ['Michael', 'Bob', 'Tracy']classmates# ['Michael', 'Bob', 'Tracy'] 用len()函数可以获得list元素的个数： 1len(classmates) # 3 用索引来访问list中每一个位置的元素，记得索引是从0开始的： 1234567classmates[0] # 'Michael'classmates[1] # 'Bob'classmates[2] # 'Tracy'classmates[3]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 最后一个元素的索引是len(classmates)-1，以此类推，可以获取倒数第2个、倒数第3个： 1234567classmates[-1] # 'Tracy'classmates[-2] #'Bob'classmates[-3] # 'Michael'classmates[-4]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123classmates.append('Adam')classmates# ['Michael', 'Bob', 'Tracy', 'Adam'] 可以把元素插入到指定的位置，比如索引号为1的位置： 123classmates.insert(1,'Jack')classmates# ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素，用pop()方法： 1234classmates.pop()'Adam'classmates# ['Michael', 'Jack', 'Bob', 'Tracy'] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： 1234classmates.pop(1)'Jack'classmates# ['Michael', 'Bob', 'Tracy'] list里面的元素的数据类型也可以不同，比如： 1L = ['Apple', 123, True] list元素也可以是另一个list，比如： 12s = ['python', 'java', ['asp', 'php'], 'scheme']len(s) # 4 要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了： 12p = ['asp', 'php']s = ['python', 'java', p, 'scheme'] 要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组。 tupletuple一旦初始化就不能修改，它也没有append()，insert()这样的方法。比如同样是列出同学的名字： 1classmates = ('Michael', 'Bob', 'Tracy') 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。如果要定义一个空的tuple，可以写成()： 12t = ()t # () 但是，要定义一个只有1个元素的tuple，如果你这么定义： 12t = (1)t # 1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 12t = (1,)t # (1,) 最后来看一个“可变的”tuple： 12345t = ('a', 'b', ['A', 'B'])t[2][0] = 'X't[2][1] = 'Y't# ('a', 'b', ['X', 'Y']) 我们先看看定义的时候tuple包含的3个元素：当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 练习请用索引取出下面list的指定元素： 1234567891011L = [ ['Apple', 'Google', 'Microsoft'], ['Java', 'Python', 'Ruby', 'PHP'], ['Adam', 'Bart', 'Lisa']]# 打印Apple:print(L[0][0])# 打印Python:print(L[1][1])# 打印Lisa:print(L[2][2]) 小结list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。 四、条件判断1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 再议 input123456s = input('birth: ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') 练习小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if-elif判断并打印结果： 1234567891011121314151617height = 1.75weight = 80.5bmi = weight/(height)**2print(bmi)if bmi &lt; 0: passelif bmi &lt; 18.5: print(\"过轻\")elif bmi &lt; 25: print(\"正常\")elif bmi &lt; 28: print(\"过重\")elif bmi &lt; 32: print(\"肥胖\")else: print(\"严重肥胖\")# 过重 五、循环Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 12345678names = ['Michael', 'Bob', 'Tracy']for name in names: print(name)'''MichaelBobTracy''' 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。range(101)就可以生成0-100的整数序列，计算如下： 12345sum = 0for x in range(101): sum = sum + xprint(sum)# 5050 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 练习请利用循环依次对list中的每个名字打印出Hello, xxx!： 12345678L = ['Bart', 'Lisa', 'Adam']for l in L: print(\"Hello, %s!\" % l)'''Hello, Bart!Hello, Lisa!Hello, Adam!''' break如果要提前结束循环，可以用break语句： 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') continue如果我们想只打印奇数，可以用continue语句跳过某些循环： 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。 小结break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。 不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 六、使用dict和setdict字典使用键-值（key-value）存储，具有极快的查找速度。 12d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d['Michael'] # 95 为什么dict查找速度这么快？dict就是给定一个名字比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 dict的key必须是不可变对象。list是可变对象，不能作为key。 12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = 'a list'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unhashable type: 'list' setset可以看成数学意义上的无序和无重复元素的集合。set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合： 12s = set([1, 2, 3])s # &#123;1, 2, 3&#125; 显示的顺序也不表示set是有序的。重复元素在set中自动被过滤： 12s = set([1, 1, 2, 2, 3, 3])s # &#123;1, 2, 3&#125; 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 1234s.add(4)s # &#123;1, 2, 3, 4&#125;s.add(4)s # &#123;1, 2, 3, 4&#125; 通过remove(key)方法可以删除元素： 12s.remove(4)s # &#123;1, 2, 3&#125; 两个set可以做数学意义上的交集、并集等操作： 1234s1 = set([1, 2, 3])s2 = set([2, 3, 4])s1 &amp; s2 # &#123;2, 3&#125;s1 | s2 # &#123;1, 2, 3, 4&#125; 再议不可变对象str是不变对象，而list是可变对象。 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： 123a = ['c', 'b', 'a']a.sort()a # ['a', 'b', 'c'] 而对于不可变对象，比如str，对str进行操作呢： 123a = 'abc'a.replace('a', 'A') # 'Abc'a # 'abc' 虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？ 我们先把代码改成下面这样： 1234a = 'abc'b = a.replace('a', 'A')b # 'Abc'a # 'abc' 要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’：当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了：所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 小结使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。 tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://palmland.github.io/tags/python/"}]}]}