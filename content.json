{"meta":{"title":"PalmLand","subtitle":"Haha, genius!","description":"This is our history","author":"PalmLand","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-29T01:24:14.000Z","updated":"2019-06-29T01:25:05.343Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-29T01:26:27.000Z","updated":"2019-06-29T01:26:27.948Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《机器学习实战》-01参考笔记","slug":"《机器学习实战》-01笔记","date":"2019-07-15T02:02:49.000Z","updated":"2019-07-15T02:48:27.856Z","comments":true,"path":"2019/07/15/《机器学习实战》-01笔记/","link":"","permalink":"http://yoursite.com/2019/07/15/《机器学习实战》-01笔记/","excerpt":"本书笔记来源于Apachecn，该书分为四部分： 2~7章讲分类 8~9章讲回归 10~12章讲无监督学习 13~15章讲机器学习算法使用到的附属工具 该笔记增加了第16章推荐系统，作为实战项目","text":"本书笔记来源于Apachecn，该书分为四部分： 2~7章讲分类 8~9章讲回归 10~12章讲无监督学习 13~15章讲机器学习算法使用到的附属工具 该笔记增加了第16章推荐系统，作为实战项目 第一章: 机器学习基础 第二章: KNN 近邻算法 第三章: 决策树 第四章: 朴素贝叶斯 第五章: Logistic回归 第六章: SVM 支持向量机 第七章: 集成方法（随机森林和 AdaBoost） 第八章: 回归 第九章: 树回归 第十章: K-Means 聚类 第十一章: 利用 Apriori 算法进行关联分析 第十二章: FP-growth 高效发现频繁项集 第十三章: 利用 PCA 来简化数据 第十四章: 利用 SVD 来简化数据 第十五章: 大数据与 MapReduce 第十六章: 推荐系统（已迁移）","categories":[],"tags":[],"author":"PalmLand"},{"title":"python-04Numpy基础：数组和矢量计算","slug":"python-04Numpy基础：数组和矢量计算-1","date":"2019-07-12T01:28:06.000Z","updated":"2019-07-12T14:57:00.000Z","comments":true,"path":"2019/07/12/python-04Numpy基础：数组和矢量计算-1/","link":"","permalink":"http://yoursite.com/2019/07/12/python-04Numpy基础：数组和矢量计算-1/","excerpt":"ndarray：一种多维数组对象 通用函数：快速的元素级数组函数 利用数组进行数据处理 用于数组的文件输入输出 线性代数 伪随机数生成 示例：随机漫步","text":"ndarray：一种多维数组对象 通用函数：快速的元素级数组函数 利用数组进行数据处理 用于数组的文件输入输出 线性代数 伪随机数生成 示例：随机漫步 NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。 NumPy的部分功能如下： ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。 线性代数、随机数生成以及傅里叶变换功能。 用于集成由C、C++、Fortran等语言编写的代码的A C API。 NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为： NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。 NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。 numpy可以高效处理大数组的数据 123456789import numpy as npmy_arr = np.arange(100000)my_list = list(range(100000))%time for _ in range(10): my_arr2 = my_arr *2# Wall time: 1 ms%time for _ in range(10): my_list2 = my_list *2# Wall time: 32.9 ms 一、NumPy的ndarray：一种多维数组对象NumPy最重要的一个特点就是其N维数组对象（即ndarray），是一个快速而灵活的大数据集容器。可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。 12345678910111213data = np.random.randn(2,3)data# array([[ 0.5830263 , -0.39590117, 0.72400691], [ 0.83895026, -0.1634468 , -1.55589942]]) # 进行数学运算：data*10# array([[ 5.83026299, -3.95901173, 7.24006906], [ 8.38950264, -1.63446803, -15.5589942 ]]) data+data# array([[ 2.47469633, 0.01421658, 0.21865621], [ 3.72025764, -0.31933374, -0.8535659 ]]) 每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）： 12345data.shape # (2,3)data.dtype # dtype(&apos;float64&apos;)data.ndim # 维度是2 创建ndarray创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例： 12345678data1 = [3,5.9,2,6]arr1 = np.array(data1)arr1 # array([3. , 5.9, 2. , 6. ])data2 = [[3,9,2,6],[29,4,3,16]]arr2 = np.array(data2)arr2 # array([[ 3, 9, 2, 6], [29, 4, 3, 16]]) 因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证： 123arr2.ndim # 2arr2.shape # (2, 4) np.array会尝试为新建的这个数组推断出一个较为合适的数据类型： 1arr2.dtype # dtype(&apos;int32&apos;) 除np.array之外，还有一些函数也可以新建数组。 zeros和ones分别可以创建指定长度或形状的全0或全1数组。 12np.zeros(10) # array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) empty可以创建一个没有任何具体值的数组。 123np.empty((2,4))# array([[0., 0., 0., 0.], [0., 0., 0., 0.]]) 认为np.empty会返回全0数组的想法是不安全的，很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。 arange是Python内置函数range的数组版。 123np.arange(15)# array([[3, 3, 3, 3], [3, 3, 3, 3]]) eye可以创建一个N*N的数组（对角线为1其余为0） 123456789np.eye(6)&apos;&apos;&apos;array([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]])&apos;&apos;&apos; full可以创建全部为指定值的数组 12345np.full((2,4),3)&apos;&apos;&apos;array([[3, 3, 3, 3], [3, 3, 3, 3]])&apos;&apos;&apos; ndarray的数据类型使用dtype指定数组数据类型： 12arr1 = np.array([1,2,3],dtype=np.float64)arr1.dtype # dtype(&apos;float64&apos;) Numpy的数据类型：可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype： 12345arr = np.array([1,2,3,4])arr.dtype # dtype(&apos;int32&apos;)float_arr = arr.astype(np.float64)float_arr.dtype # dtype(&apos;float64&apos;) 在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除： 12arr = np.array([1.7,20.6,0.93,4])arr.astype(np.int32) # array([ 1, 20, 0, 4]) 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式： 12numeric_strings = np.array([&apos;1.24&apos;,&apos;6.99&apos;],dtype=np.string_)numeric_strings.astype(float) # array([1.24, 6.99]) 如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。上面写的是float而不np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。 数组的dtype还有另一个属性，将一个数组类型转化成另一个数组的类型： 123int_array = np.arange(10)xx = np.array([.33,.24,.5])int_array.astype(xx.dtype) 你还可以用简洁的类型代码来表示dtype： 123456empty_uint32 = np.empty(8, dtype=&apos;u4&apos;)empty_uint32&apos;&apos;&apos;array([ 0, 1075314688, 0, 1075707904, 0, 1075838976, 0, 1072693248], dtype=uint32)&apos;&apos;&apos; 调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。 NumPy数组的运算大小相等的数组之间的任何算术运算都会将运算应用到元素级： 1234567891011121314151617arr = np.array([[1., 2., 3.], [4., 5., 6.]])arr * arr # array([[ 1., 4., 9.], [ 16., 25., 36.]]) arr - arr# array([[ 0., 0., 0.], [ 0., 0., 0.]]) 1 / arr# array([[ 1. , 0.5 , 0.3333], [ 0.25 , 0.2 , 0.1667]]) arr ** 0.5# array([[ 1. , 1.4142, 1.7321], [ 2. , 2.2361, 2.4495]]) 大小相同的数组之间的比较会生成布尔值数组： 1234arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])arr2 &gt; arr# array([[False, True, False], [ True, False, True]], dtype=bool) 基本的索引和切片本节参考自《利用python进行数据分析》第四章，阅读链接：https://wizardforcel.gitbooks.io/pyda-2e/content/4.html","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-03高级特性","slug":"python-03高级特性","date":"2019-07-11T10:03:00.000Z","updated":"2019-07-12T14:04:53.414Z","comments":true,"path":"2019/07/11/python-03高级特性/","link":"","permalink":"http://yoursite.com/2019/07/11/python-03高级特性/","excerpt":"切片 迭代 列表生成式 生成器 迭代器","text":"切片 迭代 列表生成式 生成器 迭代器 这一节介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。 一、切片一个list如下： 1L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 或者取前N个元素，也就是索引为0-(N-1)的元素，可以用循环。 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 1234&gt;&gt;&gt; L[-2:][&apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; L[-2:-1][&apos;Bob&apos;] 切片操作十分有用。我们先创建一个0-99的数列： 123&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如后10个数： 12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前10个数，每两个取一个： 12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 甚至什么都不写，只写[:]就可以原样复制一个list： 12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： 12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 1234&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 练习利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法： 1234567891011121314151617181920212223242526272829303132333435363738def trim(s): if n == &apos;&apos; return s else: n = 0 m = len(s) while s[n] == &apos; &apos; and n &lt; m-1: n += 1 while s[m-1] == &apos; &apos; and m &gt; n: m -= 1 return s[n:m]# 或者&apos;&apos;&apos;def trim(s): if len(s) != 0: while s[:1] == &apos; &apos;: s = s[1:] while s[-1:] == &apos; &apos;: s = s[:-1] return s&apos;&apos;&apos;# 测试:if trim(&apos;hello &apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello&apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello &apos;) != &apos;hello&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; hello world &apos;) != &apos;hello world&apos;: print(&apos;测试失败!&apos;)elif trim(&apos;&apos;) != &apos;&apos;: print(&apos;测试失败!&apos;)elif trim(&apos; &apos;) != &apos;&apos;: print(&apos;测试失败!&apos;)else: print(&apos;测试成功!&apos;) 小结有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。 二、迭代如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过for … in来完成的。Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。比如dict就可以迭代： 123456&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; for key in d: print(key)acb 默认情况下，dict迭代的是key; 如果要迭代value，可以用for value in d.values(); 如果要同时迭代key和value，可以用for k, v in d.items()。 那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 123456&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print(i, value)...0 A1 B2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 练习请使用迭代查找一个list中最小和最大值，并返回一个tuple： 123456789101112131415161718def findMinAndMax(L): if L == []: return(None,None) else: return(min(L),max(L))# 测试if findMinAndMax([]) != (None, None): print(&apos;测试失败!&apos;)elif findMinAndMax([7]) != (7, 7): print(&apos;测试失败!&apos;)elif findMinAndMax([7, 1]) != (1, 7): print(&apos;测试失败!&apos;)elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9): print(&apos;测试失败!&apos;)else: print(&apos;测试成功!&apos;) 三、列表生成式列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式。举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))： 1list(range(1,11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： 12&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;][&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 三层和三层以上的循环就很少用到了。 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： 123&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 列表生成式也可以使用两个变量来生成list： 123&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()][&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： 123&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]&gt;&gt;&gt; [s.lower() for s in L][&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 练习如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错： 123456&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]&gt;&gt;&gt; [s.lower() for s in L]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;listcomp&gt;AttributeError: &apos;int&apos; object has no attribute &apos;lower&apos; 使用内建的isinstance函数可以判断一个变量是不是字符串： 123456&gt;&gt;&gt; x = &apos;abc&apos;&gt;&gt;&gt; y = 123&gt;&gt;&gt; isinstance(x, str)True&gt;&gt;&gt; isinstance(y, str)False 请修改列表生成式，通过添加if语句保证列表生成式能正确地执行： 12345678910L1 = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None]L2 = [s.lower() for s in L1 if isinstance(s, str)]# 测试:print(L2)if L2 == [&apos;hello&apos;, &apos;world&apos;, &apos;apple&apos;]: print(&apos;测试通过!&apos;)else: print(&apos;测试失败!&apos;)# 测试通过! 四、生成器通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 创建一个generator有很多种方法。 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 我们怎么打印出generator的每一个元素呢？如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值： 123456789101112131415161718192021222324&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 但上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象： 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)... 0149162536496481 generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 第二种方法是使用关键字yield 比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：1, 1, 2, 3, 5, 8, 13, 21, 34, … 斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return &apos;done&apos; 仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &apos;done&apos; 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator： 123&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 举个简单的例子，定义一个generator，依次返回数字1，3，5： 1234567def odd(): print(&apos;step 1&apos;) yield(1) print(&apos;step 2&apos;) yield(3) print(&apos;step 3&apos;) yield(5) 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值： 1234567891011121314&gt;&gt;&gt; o = odd()&gt;&gt;&gt; next(o)step 11&gt;&gt;&gt; next(o)step 23&gt;&gt;&gt; next(o)step 35&gt;&gt;&gt; next(o)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。 回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。 同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代： 123456789&gt;&gt;&gt; for n in fib(6):... print(n)...112358 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 12345678910111213141516&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print(&apos;g:&apos;, x)... except StopIteration as e:... print(&apos;Generator return value:&apos;, e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 练习杨辉三角定义如下： 1234567891011 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 把每一行看做一个list，试写一个generator，不断输出下一行的list： 123456789101112131415161718192021222324252627282930313233343536373839404142def triangles(): L = [1] yield L while True: L=[1]+[L[x]+L[x+1] for x in range(len(L)-1)]+[1] yield L# 期待输出:# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 10: break if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print(&apos;测试通过!&apos;)else: print(&apos;测试失败!&apos;) 小结在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。 要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。 请注意区分普通函数和generator函数，普通函数调用直接返回结果： 123&gt;&gt;&gt; r = abs(6)&gt;&gt;&gt; r6 generator函数的“调用”实际返回一个generator对象： 123&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; g&lt;generator object fib at 0x1022ef948&gt; 五、迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 集合数据类型，如list、tuple、dict、set、str等； generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象： 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False 生成器generator都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 小结凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如： 1234567891011121314for x in [1, 2, 3, 4, 5]: pass实际上完全等价于：# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232","categories":[],"tags":[],"author":"PalmLand"},{"title":"python-02函数","slug":"python-02函数","date":"2019-05-26T03:35:37.000Z","updated":"2019-05-27T11:05:46.000Z","comments":true,"path":"2019/05/26/python-02函数/","link":"","permalink":"http://yoursite.com/2019/05/26/python-02函数/","excerpt":"调用函数 定义函数 函数的参数 递归函数","text":"调用函数 定义函数 函数的参数 递归函数 一、调用函数Python内置了很多有用的函数，可以直接调用。https://docs.python.org/3/library/functions.html比如求绝对值的函数abs，只有一个参数，可以在交互式命令行通过help(abs)查看abs函数的帮助信息。 12345help(abs)Help on built-in function abs in module builtins:abs(x, /) Return the absolute value of the argument. 调用abs函数： 1abs(-20) # 20 数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： 123int(&apos;123&apos;) # 123int(12.34) # 12bool(&apos;&apos;) # False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 12a = abs # 变量a指向abs函数a(-1) # 所以也可以通过a调用abs函数,返回1 练习利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串 12n1 = 255hex(n1) # &apos;0xff&apos; 二、定义函数以自定义一个求绝对值的my_abs函数为例： 123456def my_abs(x): if x &gt;= 0: return x else: return -xprint(my_abs(-99)) # 99 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数: 12from abstest import my_abs my_abs(-9) # 9 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass 实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 pass还可以用在其他语句里，比如： 12if age &gt;= 18: pass 缺少了pass，代码运行就会有语法错误。 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError： 1234&gt;&gt;&gt; my_abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: my_abs() takes 1 positional argument but 2 were given 但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别： 123456789&gt;&gt;&gt; my_abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in my_absTypeError: unorderable types: str() &gt;= int()&gt;&gt;&gt; abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。 修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError(&apos;bad operand type&apos;) if x &gt;= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误： 12345&gt;&gt;&gt; my_abs(&apos;A&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in my_absTypeError: bad operand type 返回多个值比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 然后，我们就可以同时获得返回值： 12x, y = move(100, 100, 60, math.pi / 6)print(x, y) # 151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 12r = move(100, 100, 60, math.pi / 6)print(r) # (151.96152422706632, 70.0) 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 小结定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 练习定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的两个解。提示：使用一元二次方程的求根公式 123456789101112131415161718import mathdef quadratic(a, b, c): x1 = (-b + math.sqrt(b*b-4*a*c))/(2*a) x2 = (-b - math.sqrt(b*b-4*a*c))/(2*a) return x1,x2x1, x2 = quadratic(1, 5, 6)print(x1, x2) # -2.0 -3.0# 测试:print(&apos;quadratic(2, 3, 1) =&apos;, quadratic(2, 3, 1)) # quadratic(2, 3, 1) = (-0.5, -1.0)print(&apos;quadratic(1, 3, -4) =&apos;, quadratic(1, 3, -4)) # quadratic(1, 3, -4) = (1.0, -4.0)if quadratic(2, 3, 1) != (-0.5, -1.0): print(&apos;测试失败&apos;)elif quadratic(1, 3, -4) != (1.0, -4.0): print(&apos;测试失败&apos;)else: print(&apos;测试成功&apos;) # 测试成功 三、函数的参数除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数我们先写一个计算$x^2$的函数： 12def power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。 当我们调用power函数时，必须传入有且仅有的一个参数x 1power(5) # 25 现在，如果我们要计算$x^3$怎么办？可以再定义一个power3函数，但是如果要计算$x^4$、$x^5$……怎么办？我们不可能定义无限多个函数。 可以把power(x)修改为power(x, n)，用来计算$x^n$： 1234567def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5, 2) # 25 修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 默认参数新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用： 1234&gt;&gt;&gt; power(5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: &apos;n&apos; Python的错误信息很明确：调用函数power()缺少了一个位置参数n。 这个时候，默认参数就排上用场了。由于我们经常计算$x^2$，所以，完全可以把第二个参数n的默认值设定为2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样，当我们调用power(5)时，相当于调用power(5, 2)： 12power(5) # 25power(5, 2) # 25 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 使用默认参数有什么好处？最大的好处是能降低调用函数的难。 可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算$a^2 + b^2 + c^2 + ……$。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 12calc([1, 2, 3]) # 14calc((1, 3, 5, 7)) # 84 我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 利用可变参数，调用函数的方式可以简化成这样： 123calc(1, 2, 3) # 14calc(1, 3, 5, 7) # 84calc() # 0 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： 12nums = [1, 2, 3]calc(nums[0], nums[1], nums[2]) # 14 这种写法太繁琐，Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： 12nums = [1, 2, 3]calc(*nums) # 14 *nums表示把nums这个list的所有元素作为可变参数传进去。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 12def person(name, age, **kw): print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 1person(&apos;Michael&apos;, 30) # name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 关键字参数有什么用？它可以扩展函数的功能。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 当然，上面复杂的调用可以用简化的写法： 123extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;person(&apos;Jack&apos;, 24, **extra)# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数： 12345678def person(name, age, **kw): if &apos;city&apos; in kw: # 有city参数 pass if &apos;job&apos; in kw: # 有job参数 pass print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 但调用者仍可以传入不受限制的关键字参数： 12person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, addr=&apos;Chaoyang&apos;, zipcode=123456)# name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;addr&apos;: &apos;Chaoyang&apos;, &apos;zipcode&apos;: 123456&#125; 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数*kw不同，命名关键字参数需要一个特殊分隔符，*后面的参数(city, job)被视为命名关键字参数。 调用方式如下： 12person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)# Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： 12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错： 1234&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。若改为： 12person(&apos;Jack&apos;, 24, city = &apos;Beijing&apos;, job = &apos;Engineer&apos;)# Jack 24 () Beijing Engineer 则没错。命名关键字参数可以有缺省值，从而简化调用： 12def person(name, age, *, city=&apos;Beijing&apos;, job): print(name, age, city, job) 由于命名关键字参数city具有默认值，调用时，可不传入city参数： 12person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)# Jack 24 Beijing Engineer 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个作为特殊分隔符。如果缺少，Python解释器将无法识别位置参数和命名关键字参数： 123def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。比如定义一个函数，包含上述若干种参数： 12345def f1(a, b, c=0, *args, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)def f2(a, b, c=0, *, d, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw) 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数： 12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125; 所以，对于任意函数，都可以通过类似func(args, *kw)的形式调用它，无论它的参数是如何定义的。 练习接收一个或多个数并计算乘积： 123456789101112131415161718192021222324252627def product(*numbers): sum = 1 if len(numbers) == 0: raise TypeError(&apos;参数不能为空, 否则没有意义!&apos;) else: for n in numbers: sum = sum * n return sumprint(&apos;product(5) =&apos;, product(5))print(&apos;product(5, 6) =&apos;, product(5, 6))print(&apos;product(5, 6, 7) =&apos;, product(5, 6, 7))print(&apos;product(5, 6, 7, 9) =&apos;, product(5, 6, 7, 9))if product(5) != 5: print(&apos;测试1失败!&apos;)elif product(5, 6) != 30: print(&apos;测试2失败!&apos;)elif product(5, 6, 7) != 210: print(&apos;测试3失败!&apos;)elif product(5, 6, 7, 9) != 1890: print(&apos;测试4失败!&apos;)else: try: product() print(&apos;测试5失败!&apos;) except TypeError: print(&apos;测试6成功!&apos;)product() 1234567product(5) = 5product(5, 6) = 30product(5, 6, 7) = 210product(5, 6, 7, 9) = 1890测试6成功! 小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 四、递归函数如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘$n! = 1 x 2 x 3 x … x n$，用函数fact(n)表示，可以看出： fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n 所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 12&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： 1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 4, in fact ... File &quot;&lt;stdin&gt;&quot;, line 4, in factRuntimeError: maximum recursion depth exceeded in comparison 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。 fact(5)对应的fact_iter(5, 1)的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。 小结使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。 练习汉诺塔的移动可以用递归函数非常简单地实现。 编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如： 1234567891011def move(n, a, b, c): if n == 1: print(a,&apos;--&gt;&apos;,c) else: # 先将a柱子上的（前）N-1个圆盘借助c移动到柱子b上； move(n-1,a, c, b) # 再把a上最后的大圆盘挪动到c上 move(1,a, b, c) # 最后把b上的n-1个圆盘挪动到c上 move(n-1,b, a, c)move(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;) 结果： 1234567# A --&gt; C# A --&gt; B# C --&gt; B# A --&gt; C# B --&gt; A# B --&gt; C# A --&gt; C 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017105145133280","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-01基础","slug":"python-01基础","date":"2019-05-24T02:44:59.000Z","updated":"2019-06-04T01:28:06.000Z","comments":true,"path":"2019/05/24/python-01基础/","link":"","permalink":"http://yoursite.com/2019/05/24/python-01基础/","excerpt":"数据类型和变量 字符串和编码 list和tuple 条件判断 循环 dict和set","text":"数据类型和变量 字符串和编码 list和tuple 条件判断 循环 dict和set 一、数据类型和变量在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数。对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 1print(&apos;I\\&apos;m \\&quot;OK\\&quot;!&apos;) # I&apos;m &quot;OK&quot;! \\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\ 123456print(&apos;\\\\\\n\\\\&apos;)&apos;&apos;&apos;输出：\\\\&apos;&apos;&apos; 为了简化，Python还允许用r’’表示’’内部的字符串默认不转义 12345678910print(&apos;\\\\\\t\\\\&apos;) &apos;&apos;&apos;输出：\\ \\&apos;&apos;&apos;print(r&apos;\\\\\\t\\\\&apos;)&apos;&apos;&apos;输出：\\\\\\t\\\\&apos;&apos;&apos; Python允许用’’’…’’’的格式表示多行内容 123456789print(&apos;&apos;&apos;line1line2line3&apos;&apos;&apos;)&apos;&apos;&apos;输出：line1line2line3&apos;&apos;&apos; 布尔值一个布尔值只有True、False两种值，要么是True，要么是False。 13 &gt; 2 # True 布尔值可以用and、or和not运算。 123456True and True # TrueTrue or False # TrueFalse or False # False5 &gt; 3 or 1 &gt; 3 # Truenot True # Falsenot 1 &gt; 2 # True 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如： 1a = 1 # 变量a是一个整数 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print(a) # 123a = &apos;ABC&apos; # a变为字符串print(a) # ABC 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下： 12int a = 123; // a是整数类型变量a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 理解变量在计算机内存中的表示也非常重要。当我们写： 1a = &apos;ABC&apos; 时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b) 1.执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’; 2.执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’; 3.执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改。 所以，最后打印变量b的结果自然是’ABC’了。 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量： 1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 110 / 3 # 3.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 19 / 3 # 3.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 110 // 3 # 3 整数的地板除//永远是整数，即使除不尽。 Python还提供一个余数运算，可以得到两个整数相除的余数： 110 % 3 # 1 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 练习请打印出以下变量的值： 123456789101112131415n = 123f = 456.789s1 = &apos;Hello, world&apos;s2 = &apos;Hello, \\&apos;Adam\\&apos;&apos;s3 = r&apos;Hello, &quot;Bart&quot;&apos;s4 = r&apos;&apos;&apos;Hello,Lisa!&apos;&apos;&apos;print(n) # 123print(f) # 456.789print(s1) # Hello, worldprint(s2) # Hello, &apos;Adam&apos;print(s3) # Hello, &quot;Bart&quot;print(s4) Hello,Lisa! 小结Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。 注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。 Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 二、字符串和编码字符编码字符串比较特殊的是有一个编码问题。 全世界有上百种语言，中国制定了GB2312编码，用来把中文编进去，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码。 Python的字符串在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如： 1print(&apos;包含中文的str&apos;) # 包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 1234ord(&apos;A&apos;) # 65ord(&apos;中&apos;) # 20013chr(66) # &apos;B&apos;chr(25991) # &apos;文&apos; 如果知道字符的整数编码，还可以用十六进制这么写str： 1&apos;\\u4e2d\\u6587&apos; # &apos;中文&apos; 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678&apos;ABC&apos;.encode(&apos;ascii&apos;) # b&apos;ABC&apos;&apos;中文&apos;.encode(&apos;utf-8&apos;) # b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;&apos;中文&apos;.encode(&apos;ascii&apos;) &apos;&apos;&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)&apos;&apos;&apos; 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 12b&apos;ABC&apos;.decode(&apos;ascii&apos;) # &apos;ABC&apos;b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;.decode(&apos;utf-8&apos;) # &apos;中文&apos; 如果bytes中包含无法解码的字节，decode()方法会报错： 123456b&apos;\\xe4\\xb8\\xad\\xff&apos;.decode(&apos;utf-8&apos;)&apos;&apos;&apos;Traceback (most recent call last): ...UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte&apos;&apos;&apos; 如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节： 1b&apos;\\xe4\\xb8\\xad\\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;) # &apos;中&apos; 要计算str包含多少个字符，可以用len()函数： 12len(&apos;ABC&apos;) # 3len(&apos;中文&apos;) # 2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123len(b&apos;ABC&apos;) # 3len(b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;) # 6len(&apos;中文&apos;.encode(&apos;utf-8&apos;)) # 6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。 如果.py文件本身使用UTF-8编码，并且也申明了# -- coding: utf-8 --，打开命令提示符测试就可以正常显示中文。 格式化最后一个常见的问题是如何输出格式化的字符串。 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 12345&apos;Hello, %s&apos; % &apos;world&apos; # &apos;Hello, world&apos;&apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) # &apos;Hi, Michael, you have $1000000.&apos; %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12print(&apos;%02d-%02d&apos; % (3, 1)) # 03-01print(&apos;%.2f&apos; % 3.1415926) # 3.14 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： 12&apos;Age: %s. Gender: %s&apos; % (25, True) # &apos;Age: 25. Gender: True&apos; 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个% 12&apos;growth rate: %d %%&apos; % 7&apos; # growth rate: 7 %&apos; 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12&apos;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&apos;.format(&apos;小明&apos;, 17.125) # &apos;Hello, 小明, 成绩提升了 17.1%&apos; 练习小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出’xx.x%’，只保留小数点后1位： 123456s1 = 72s2 = 85r = (s2-s1)/s1r = r*100print(&apos;%.1f%%&apos; % r)# 18.1% 小结Python 3的字符串使用Unicode，直接支持多语言。 当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312： 12&apos;中文&apos;.encode(&apos;gb2312&apos;)# b&apos;\\xd6\\xd0\\xce\\xc4&apos; 但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。 格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。 三、使用list和tuplelistlist是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 123classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]classmates# [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 用len()函数可以获得list元素的个数： 1len(classmates) # 3 用索引来访问list中每一个位置的元素，记得索引是从0开始的： 1234567classmates[0] # &apos;Michael&apos;classmates[1] # &apos;Bob&apos;classmates[2] # &apos;Tracy&apos;classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 最后一个元素的索引是len(classmates)-1，以此类推，可以获取倒数第2个、倒数第3个： 1234567classmates[-1] # &apos;Tracy&apos;classmates[-2] #&apos;Bob&apos;classmates[-3] # &apos;Michael&apos;classmates[-4]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123classmates.append(&apos;Adam&apos;)classmates# [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 可以把元素插入到指定的位置，比如索引号为1的位置： 123classmates.insert(1,&apos;Jack&apos;)classmates# [&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 要删除list末尾的元素，用pop()方法： 1234classmates.pop()&apos;Adam&apos;classmates# [&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： 1234classmates.pop(1)&apos;Jack&apos;classmates# [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] list里面的元素的数据类型也可以不同，比如： 1L = [&apos;Apple&apos;, 123, True] list元素也可以是另一个list，比如： 12s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]len(s) # 4 要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了： 12p = [&apos;asp&apos;, &apos;php&apos;]s = [&apos;python&apos;, &apos;java&apos;, p, &apos;scheme&apos;] 要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组。 tupletuple一旦初始化就不能修改，它也没有append()，insert()这样的方法。比如同样是列出同学的名字： 1classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;) 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。如果要定义一个空的tuple，可以写成()： 12t = ()t # () 但是，要定义一个只有1个元素的tuple，如果你这么定义： 12t = (1)t # 1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 12t = (1,)t # (1,) 最后来看一个“可变的”tuple： 12345t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])t[2][0] = &apos;X&apos;t[2][1] = &apos;Y&apos;t# (&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 我们先看看定义的时候tuple包含的3个元素：当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 练习请用索引取出下面list的指定元素： 1234567891011L = [ [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;], [&apos;Java&apos;, &apos;Python&apos;, &apos;Ruby&apos;, &apos;PHP&apos;], [&apos;Adam&apos;, &apos;Bart&apos;, &apos;Lisa&apos;]]# 打印Apple:print(L[0][0])# 打印Python:print(L[1][1])# 打印Lisa:print(L[2][2]) 小结list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。 四、条件判断1234567age = 3if age &gt;= 18: print(&apos;adult&apos;)elif age &gt;= 6: print(&apos;teenager&apos;)else: print(&apos;kid&apos;) 再议 input123456s = input(&apos;birth: &apos;)birth = int(s)if birth &lt; 2000: print(&apos;00前&apos;)else: print(&apos;00后&apos;) 练习小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if-elif判断并打印结果： 1234567891011121314151617height = 1.75weight = 80.5bmi = weight/(height)**2print(bmi)if bmi &lt; 0: passelif bmi &lt; 18.5: print(&quot;过轻&quot;)elif bmi &lt; 25: print(&quot;正常&quot;)elif bmi &lt; 28: print(&quot;过重&quot;)elif bmi &lt; 32: print(&quot;肥胖&quot;)else: print(&quot;严重肥胖&quot;)# 过重 五、循环Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 12345678names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]for name in names: print(name)&apos;&apos;&apos;MichaelBobTracy&apos;&apos;&apos; 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。range(101)就可以生成0-100的整数序列，计算如下： 12345sum = 0for x in range(101): sum = sum + xprint(sum)# 5050 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 练习请利用循环依次对list中的每个名字打印出Hello, xxx!： 12345678L = [&apos;Bart&apos;, &apos;Lisa&apos;, &apos;Adam&apos;]for l in L: print(&quot;Hello, %s!&quot; % l)&apos;&apos;&apos;Hello, Bart!Hello, Lisa!Hello, Adam!&apos;&apos;&apos; break如果要提前结束循环，可以用break语句： 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print(&apos;END&apos;) continue如果我们想只打印奇数，可以用continue语句跳过某些循环： 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。 小结break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。 不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 六、使用dict和setdict字典使用键-值（key-value）存储，具有极快的查找速度。 12d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;d[&apos;Michael&apos;] # 95 为什么dict查找速度这么快？dict就是给定一个名字比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 dict的key必须是不可变对象。list是可变对象，不能作为key。 12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = &apos;a list&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; setset可以看成数学意义上的无序和无重复元素的集合。set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合： 12&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s # &#123;1, 2, 3&#125; 显示的顺序也不表示set是有序的。重复元素在set中自动被过滤： 12&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s # &#123;1, 2, 3&#125; 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 1234&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s # &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s # &#123;1, 2, 3, 4&#125; 通过remove(key)方法可以删除元素： 12&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s # &#123;1, 2, 3&#125; 两个set可以做数学意义上的交集、并集等操作： 1234&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2 # &#123;2, 3&#125;&gt;&gt;&gt; s1 | s2 # &#123;1, 2, 3, 4&#125; 再议不可变对象str是不变对象，而list是可变对象。 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： 123&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a # [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 而对于不可变对象，比如str，对str进行操作呢： 123&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;) # &apos;Abc&apos;&gt;&gt;&gt; a # &apos;abc&apos; 虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？ 我们先把代码改成下面这样： 1234&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)&gt;&gt;&gt; b # &apos;Abc&apos;&gt;&gt;&gt; a # &apos;abc&apos; 要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’：当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了：所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 小结使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。 tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。 本节参考自廖雪峰老师的python教程，链接是：https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}