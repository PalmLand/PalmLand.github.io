<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Python-04Numpy | PalmLand</title><meta name="description" content="Python-04Numpy"><meta name="keywords" content="python"><meta name="author" content="PalmLand"><meta name="copyright" content="PalmLand"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Python-04Numpy"><meta name="twitter:description" content="Python-04Numpy"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="Python-04Numpy"><meta property="og:url" content="https://palmland.github.io/2019/07/14/python-04Numpy/"><meta property="og:site_name" content="PalmLand"><meta property="og:description" content="Python-04Numpy"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://palmland.github.io/2019/07/14/python-04Numpy/"><link rel="prev" title="Python-05Pandas" href="https://palmland.github.io/2019/07/15/python-05Pandas/"><link rel="next" title="Python-03高级特性" href="https://palmland.github.io/2019/07/11/python-03高级特性/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">PalmLand</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://c-ssl.duitang.com/uploads/item/201810/22/20181022230113_AGsHE.thumb.700_0.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一、NumPy的ndarray：一种多维数组对象"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一、NumPy的ndarray：一种多维数组对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建ndarray"><span class="toc_mobile_items-number">1.0.1.</span> <span class="toc_mobile_items-text">创建ndarray</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ndarray的数据类型"><span class="toc_mobile_items-number">1.0.2.</span> <span class="toc_mobile_items-text">ndarray的数据类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#NumPy数组的运算"><span class="toc_mobile_items-number">1.0.3.</span> <span class="toc_mobile_items-text">NumPy数组的运算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基本的索引和切片"><span class="toc_mobile_items-number">1.0.4.</span> <span class="toc_mobile_items-text">基本的索引和切片</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#切片索引"><span class="toc_mobile_items-number">1.0.5.</span> <span class="toc_mobile_items-text">切片索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#布尔型索引"><span class="toc_mobile_items-number">1.0.6.</span> <span class="toc_mobile_items-text">布尔型索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#花式索引"><span class="toc_mobile_items-number">1.0.7.</span> <span class="toc_mobile_items-text">花式索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数组转置和轴对换"><span class="toc_mobile_items-number">1.0.8.</span> <span class="toc_mobile_items-text">数组转置和轴对换</span></a></li></ol></li></ol><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二、通用函数：快速的元素级数组函数"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">二、通用函数：快速的元素级数组函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#三、利用数组进行数据处理"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">三、利用数组进行数据处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#将条件逻辑表述为数组运算"><span class="toc_mobile_items-number">3.0.1.</span> <span class="toc_mobile_items-text">将条件逻辑表述为数组运算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数学和统计方法"><span class="toc_mobile_items-number">3.0.2.</span> <span class="toc_mobile_items-text">数学和统计方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#用于布尔型数组的方法"><span class="toc_mobile_items-number">3.0.3.</span> <span class="toc_mobile_items-text">用于布尔型数组的方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#排序"><span class="toc_mobile_items-number">3.0.4.</span> <span class="toc_mobile_items-text">排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#唯一化以及其它的集合逻辑"><span class="toc_mobile_items-number">3.0.5.</span> <span class="toc_mobile_items-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#四、用于数组的文件输入输出"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">四、用于数组的文件输入输出</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#六、伪随机数生成"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">六、伪随机数生成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#七、示例：随机漫步"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">七、示例：随机漫步</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#一次模拟多个随机漫步"><span class="toc_mobile_items-number">6.0.1.</span> <span class="toc_mobile_items-text">一次模拟多个随机漫步</span></a></li></ol></li></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、NumPy的ndarray：一种多维数组对象"><span class="toc-number">1.</span> <span class="toc-text">一、NumPy的ndarray：一种多维数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建ndarray"><span class="toc-number">1.0.1.</span> <span class="toc-text">创建ndarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ndarray的数据类型"><span class="toc-number">1.0.2.</span> <span class="toc-text">ndarray的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NumPy数组的运算"><span class="toc-number">1.0.3.</span> <span class="toc-text">NumPy数组的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的索引和切片"><span class="toc-number">1.0.4.</span> <span class="toc-text">基本的索引和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片索引"><span class="toc-number">1.0.5.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔型索引"><span class="toc-number">1.0.6.</span> <span class="toc-text">布尔型索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#花式索引"><span class="toc-number">1.0.7.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组转置和轴对换"><span class="toc-number">1.0.8.</span> <span class="toc-text">数组转置和轴对换</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#二、通用函数：快速的元素级数组函数"><span class="toc-number">2.</span> <span class="toc-text">二、通用函数：快速的元素级数组函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、利用数组进行数据处理"><span class="toc-number">3.</span> <span class="toc-text">三、利用数组进行数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将条件逻辑表述为数组运算"><span class="toc-number">3.0.1.</span> <span class="toc-text">将条件逻辑表述为数组运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学和统计方法"><span class="toc-number">3.0.2.</span> <span class="toc-text">数学和统计方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用于布尔型数组的方法"><span class="toc-number">3.0.3.</span> <span class="toc-text">用于布尔型数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">3.0.4.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#唯一化以及其它的集合逻辑"><span class="toc-number">3.0.5.</span> <span class="toc-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、用于数组的文件输入输出"><span class="toc-number">4.</span> <span class="toc-text">四、用于数组的文件输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、伪随机数生成"><span class="toc-number">5.</span> <span class="toc-text">六、伪随机数生成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、示例：随机漫步"><span class="toc-number">6.</span> <span class="toc-text">七、示例：随机漫步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一次模拟多个随机漫步"><span class="toc-number">6.0.1.</span> <span class="toc-text">一次模拟多个随机漫步</span></a></li></ol></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Python-04Numpy</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-07-14<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-07-14</time><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><ul>
<li>ndarray：一种多维数组对象</li>
<li>通用函数：快速的元素级数组函数</li>
<li>利用数组进行数据处理</li>
<li>用于数组的文件输入输出</li>
<li>线性代数</li>
<li>伪随机数生成</li>
<li>示例：随机漫步</li>
</ul>
<a id="more"></a>

<p><a href="https://numpy.org/devdocs/reference/index.html" target="_blank" rel="noopener">NumPy</a>（Numerical Python的简称）是Python数值计算最重要的基础包。</p>
<p>NumPy的部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li>
</ul>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。<br>这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<p>numpy可以高效处理大数组的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">my_arr = np.arange(<span class="number">100000</span>)</span><br><span class="line">my_list = list(range(<span class="number">100000</span>))</span><br><span class="line"></span><br><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_arr2 = my_arr *<span class="number">2</span></span><br><span class="line"><span class="comment"># Wall time: 1 ms</span></span><br><span class="line"></span><br><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_list2 = my_list *<span class="number">2</span></span><br><span class="line"><span class="comment"># Wall time: 32.9 ms</span></span><br></pre></td></tr></table></figure>

<h1 id="一、NumPy的ndarray：一种多维数组对象"><a href="#一、NumPy的ndarray：一种多维数组对象" class="headerlink" title="一、NumPy的ndarray：一种多维数组对象"></a>一、NumPy的ndarray：一种多维数组对象</h1><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），是一个快速而灵活的大数据集容器。可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.5830263 , -0.39590117,  0.72400691],</span></span><br><span class="line"><span class="string">       [ 0.83895026, -0.1634468 , -1.55589942]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数学运算：</span></span><br><span class="line">data*<span class="number">10</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  5.83026299,  -3.95901173,   7.24006906],</span></span><br><span class="line"><span class="string">       [  8.38950264,  -1.63446803, -15.5589942 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">data+data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 2.47469633,  0.01421658,  0.21865621],</span></span><br><span class="line"><span class="string">       [ 3.72025764, -0.31933374, -0.8535659 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个<br>用于说明数组数据类型的对象）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data.shape <span class="comment"># (2,3)</span></span><br><span class="line"></span><br><span class="line">data.dtype <span class="comment"># dtype('float64')</span></span><br><span class="line"></span><br><span class="line">data.ndim <span class="comment"># 维度是2</span></span><br></pre></td></tr></table></figure>

<h3 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h3><p>创建数组最简单的办法就是使用<strong>array函数</strong>。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data1 = [<span class="number">3</span>,<span class="number">5.9</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1 <span class="comment"># array([3. , 5.9, 2. , 6. ])</span></span><br><span class="line"></span><br><span class="line">data2 = [[<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">29</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">16</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2 </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 3,  9,  2,  6],</span></span><br><span class="line"><span class="string">       [29,  4,  3, 16]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2.ndim <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">arr2.shape <span class="comment"># (2, 4)</span></span><br></pre></td></tr></table></figure>

<p>np.array会尝试为新建的这个数组推断出一个较为合适的数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr2.dtype <span class="comment"># dtype('int32')</span></span><br></pre></td></tr></table></figure>

<p>除np.array之外，还有一些函数也可以新建数组。</p>
<ul>
<li><p>zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>) </span><br><span class="line"><span class="comment"># array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>empty可以创建一个没有任何具体值的数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>认为np.empty会返回全0数组的想法是不安全的，很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
<ul>
<li><p>arange是Python内置函数range的数组版。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[3, 3, 3, 3],</span></span><br><span class="line"><span class="string">       [3, 3, 3, 3]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eye可以创建一个N*N的数组（对角线为1其余为0）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">6</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1., 0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 1., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 1., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 1., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0., 1., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0., 0., 1.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>full可以创建全部为指定值的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.full((<span class="number">2</span>,<span class="number">4</span>),<span class="number">3</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[3, 3, 3, 3],</span></span><br><span class="line"><span class="string">       [3, 3, 3, 3]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h3><p>使用dtype指定数组数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=np.float64)</span><br><span class="line">arr1.dtype <span class="comment"># dtype('float64')</span></span><br></pre></td></tr></table></figure>

<p>Numpy的数据类型：<br><img alt="img1" data-src="/images/python/4.1.png" class="lazyload"><br><img alt="img2" data-src="/images/python/4.2.png" class="lazyload"><br>可以通过ndarray的<strong>astype</strong>方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype('int32')</span></span><br><span class="line"></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">float_arr.dtype <span class="comment"># dtype('float64')</span></span><br></pre></td></tr></table></figure>

<p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1.7</span>,<span class="number">20.6</span>,<span class="number">0.93</span>,<span class="number">4</span>])</span><br><span class="line">arr.astype(np.int32) <span class="comment"># array([ 1, 20,  0,  4])</span></span><br></pre></td></tr></table></figure>

<p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numeric_strings = np.array([<span class="string">'1.24'</span>,<span class="string">'6.99'</span>],dtype=np.string_)</span><br><span class="line">numeric_strings.astype(float) <span class="comment"># array([1.24, 6.99])</span></span><br></pre></td></tr></table></figure>

<p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。上面写的是float而不np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p>
<p>数组的dtype还有另一个属性，将一个数组类型转化成另一个数组的类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int_array = np.arange(<span class="number">10</span>)</span><br><span class="line">xx = np.array([<span class="number">.33</span>,<span class="number">.24</span>,<span class="number">.5</span>])</span><br><span class="line">int_array.astype(xx.dtype)</span><br></pre></td></tr></table></figure>

<p>你还可以用简洁的类型代码来表示dtype：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">'u4'</span>)</span><br><span class="line">empty_uint32</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([         0, 1075314688,          0, 1075707904,          0,</span></span><br><span class="line"><span class="string">       1075838976,          0, 1072693248], dtype=uint32)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
</blockquote>
<h3 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h3><p>大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">arr * arr </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  1.,   4.,   9.],</span></span><br><span class="line"><span class="string">       [ 16.,  25.,  36.]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line">arr - arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line"><span class="number">1</span> / arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.    ,  0.5   ,  0.3333],</span></span><br><span class="line"><span class="string">       [ 0.25  ,  0.2   ,  0.1667]])</span></span><br><span class="line"><span class="string">'''</span>       </span><br><span class="line">arr ** <span class="number">0.5</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.    ,  1.4142,  1.7321],</span></span><br><span class="line"><span class="string">       [ 2.    ,  2.2361,  2.4495]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([[<span class="number">0.</span>, <span class="number">4.</span>, <span class="number">1.</span>], [<span class="number">7.</span>, <span class="number">2.</span>, <span class="number">12.</span>]])</span><br><span class="line">arr2 &gt; arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[False,  True, False],</span></span><br><span class="line"><span class="string">       [ True, False,  True]], dtype=bool)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line">arr </span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span></span><br></pre></td></tr></table></figure>

<p>当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（广播）到整个选区。跟列表最重要的区别在于，<strong>数组切片是原始数组的视图</strong>。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。<br>作为例子，先创建一个arr的切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice</span><br><span class="line"><span class="comment"># array([12, 12, 12])</span></span><br></pre></td></tr></table></figure>

<p>切片[ : ]会给数组中的所有值赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_slice[:] = <span class="number">64</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">arr2d[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p>访问单个元素，下面两种方式是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>] <span class="comment"># 3</span></span><br><span class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>] <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h3 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])</span></span><br><span class="line">arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># array([ 1,  2,  3,  4, 64])</span></span><br></pre></td></tr></table></figure>

<p>对于之前的二维数组arr2d，其切片方式稍显不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arr2d </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [4, 5, 6],</span></span><br><span class="line"><span class="string">       [7, 8, 9]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [4, 5, 6]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2, 3],</span></span><br><span class="line"><span class="string">       [5, 6]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [4],</span></span><br><span class="line"><span class="string">       [7]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.0072, -1.2962,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864, -2.0016, -0.3718],</span></span><br><span class="line"><span class="string">       [ 1.669 , -0.4386, -0.5397,  0.477 ],</span></span><br><span class="line"><span class="string">       [ 3.2489, -1.0212, -0.5771,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [-0.7135, -0.8312, -2.3702, -1.8608]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>我们想要选出对应于名字”Bob”的所有行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names == <span class="string">'Bob'</span></span><br><span class="line"><span class="comment"># array([ True, False, False,  True, False, False, False], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<p>这个布尔型数组可用于数组索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.669 , -0.4386, -0.5397,  0.477 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>下面的例子，我选取了<code>names == &#39;Bob&#39;</code>的行，并索引了列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [-0.5397,  0.477 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>~操作符用来反转条件很好用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cond = names == <span class="string">'Bob'</span></span><br><span class="line">data[~cond]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.0072, -1.2962,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864, -2.0016, -0.3718],</span></span><br><span class="line"><span class="string">       [ 3.2489, -1.0212, -0.5771,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [-0.7135, -0.8312, -2.3702, -1.8608]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)</span><br><span class="line">mask</span><br><span class="line"><span class="comment"># array([ True, False,  True,  True,  True, False, False], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
</blockquote>
<p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.0929,  0.2817,  0.769 ,  1.2464],</span></span><br><span class="line"><span class="string">       [ 1.0072,  0.    ,  0.275 ,  0.2289],</span></span><br><span class="line"><span class="string">       [ 1.3529,  0.8864,  0.    ,  0.    ],</span></span><br><span class="line"><span class="string">       [ 1.669 ,  0.    ,  0.    ,  0.477 ],</span></span><br><span class="line"><span class="string">       [ 3.2489,  0.    ,  0.    ,  0.1241],</span></span><br><span class="line"><span class="string">       [ 0.3026,  0.5238,  0.0009,  1.3438],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    ,  0.    ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引指的是利用整数数组进行索引。假设我们有一个8×4数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">	arr[i] = i</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 1.,  1.,  1.,  1.],</span></span><br><span class="line"><span class="string">       [ 2.,  2.,  2.,  2.],</span></span><br><span class="line"><span class="string">       [ 3.,  3.,  3.,  3.],</span></span><br><span class="line"><span class="string">       [ 4.,  4.,  4.,  4.],</span></span><br><span class="line"><span class="string">       [ 5.,  5.,  5.,  5.],</span></span><br><span class="line"><span class="string">       [ 6.,  6.,  6.,  6.],</span></span><br><span class="line"><span class="string">       [ 7.,  7.,  7.,  7.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]] </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 4.,  4.,  4.,  4.],</span></span><br><span class="line"><span class="string">       [ 3.,  3.,  3.,  3.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 6.,  6.,  6.,  6.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">       [12, 13, 14, 15],</span></span><br><span class="line"><span class="string">       [16, 17, 18, 19],</span></span><br><span class="line"><span class="string">       [20, 21, 22, 23],</span></span><br><span class="line"><span class="string">       [24, 25, 26, 27],</span></span><br><span class="line"><span class="string">       [28, 29, 30, 31]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="comment"># array([ 4, 23, 29, 10])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 4,  7,  5,  6],</span></span><br><span class="line"><span class="string">       [20, 23, 21, 22],</span></span><br><span class="line"><span class="string">       [28, 31, 29, 30],</span></span><br><span class="line"><span class="string">       [ 8, 11,  9, 10]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
</blockquote>
<h3 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3,  4],</span></span><br><span class="line"><span class="string">       [ 5,  6,  7,  8,  9],</span></span><br><span class="line"><span class="string">       [10, 11, 12, 13, 14]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.T</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0,  5, 10],</span></span><br><span class="line"><span class="string">       [ 1,  6, 11],</span></span><br><span class="line"><span class="string">       [ 2,  7, 12],</span></span><br><span class="line"><span class="string">       [ 3,  8, 13],</span></span><br><span class="line"><span class="string">       [ 4,  9, 14]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>利用np.dot计算矩阵内积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[-0.8608,  0.5601, -1.2659],</span></span><br><span class="line"><span class="string">       [ 0.1198, -1.0635,  0.3329],</span></span><br><span class="line"><span class="string">       [-2.3594, -0.1995, -1.542 ],</span></span><br><span class="line"><span class="string">       [-0.9707, -1.307 ,  0.2863],</span></span><br><span class="line"><span class="string">       [ 0.378 , -0.7539,  0.3313],</span></span><br><span class="line"><span class="string">       [ 1.3497,  0.0699,  0.2467]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">np.dot(arr.T, arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 9.2291,  0.9394,  4.948 ],</span></span><br><span class="line"><span class="string">       [ 0.9394,  3.7662, -1.3622],</span></span><br><span class="line"><span class="string">       [ 4.948 , -1.3622,  4.3437]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 8,  9, 10, 11]],</span></span><br><span class="line"><span class="string">       [[ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。<br>ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[ 0,  4],</span></span><br><span class="line"><span class="string">        [ 1,  5],</span></span><br><span class="line"><span class="string">        [ 2,  6],</span></span><br><span class="line"><span class="string">        [ 3,  7]],</span></span><br><span class="line"><span class="string">       [[ 8, 12],</span></span><br><span class="line"><span class="string">        [ 9, 13],</span></span><br><span class="line"><span class="string">        [10, 14],</span></span><br><span class="line"><span class="string">        [11, 15]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p>
<h1 id="二、通用函数：快速的元素级数组函数"><a href="#二、通用函数：快速的元素级数组函数" class="headerlink" title="二、通用函数：快速的元素级数组函数"></a>二、通用函数：快速的元素级数组函数</h1><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。<br>以下是一元（unary）ufunc：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([ 0.    ,  1.    ,  1.4142,  1.7321,  2.    , </span></span><br><span class="line"><span class="string">2.2361,  2.4495,  2.6458,  2.8284,  3.    ])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">np.exp(arr)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([    1.    ,     2.7183,     7.3891,    20.0855,    54.5982,</span></span><br><span class="line"><span class="string">         148.4132,   403.4288,  1096.6332,  2980.958 ,  8103.0839])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">8</span>)</span><br><span class="line">y = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="comment"># array([-0.0119,  1.0048,  1.3272, -0.9193, -1.5491,  0.0222,  0.7584, -0.6605])</span></span><br><span class="line"></span><br><span class="line">y</span><br><span class="line"><span class="comment"># array([ 0.8626, -0.01  ,  0.05  ,  0.6702,  0.853 , -0.9559, -0.0235,  -2.3042])</span></span><br><span class="line">       </span><br><span class="line">np.maximum(x, y)</span><br><span class="line"><span class="comment"># array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,  -0.6605])</span></span><br></pre></td></tr></table></figure>

<p>有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])</span></span><br><span class="line"></span><br><span class="line">remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">remainder</span><br><span class="line"><span class="comment"># array([-0.2623, -0.0915, -0.663 ,  0.3731, 0.6182,  0.45  ,  0.0077])</span></span><br><span class="line"></span><br><span class="line">whole_part</span><br><span class="line"><span class="comment"># array([-3., -6., -6.,  5.,  3.,  3.,  5.])</span></span><br></pre></td></tr></table></figure>

<p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="comment"># array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr)</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br><span class="line"></span><br><span class="line">np.sqrt(arr, arr)</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span></span><br></pre></td></tr></table></figure>

<p>下面两个表分别列出了一些一元和二元ufunc。<br><img alt="img3-1" data-src="/images/python/4.3.png" class="lazyload"><br><img alt="img3-2" data-src="/images/python/4.3.2.png" class="lazyload"><br><img alt="img4" data-src="/images/python/4.4.png" class="lazyload"></p>
<h1 id="三、利用数组进行数据处理"><a href="#三、利用数组进行数据处理" class="headerlink" title="三、利用数组进行数据处理"></a>三、利用数组进行数据处理</h1><p>假设我们想要在一组值（网格型）上计算函数sqrt(x^2+y^2)。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line">xs, ys = np.meshgrid(points, points)</span><br><span class="line">ys</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],</span></span><br><span class="line"><span class="string">       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],</span></span><br><span class="line"><span class="string">       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],</span></span><br><span class="line"><span class="string">       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],</span></span><br><span class="line"><span class="string">       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">z</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 7.0711,  7.064 ,  7.0569, ...,  7.0499,  7.0569,  7.064 ],</span></span><br><span class="line"><span class="string">       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569],</span></span><br><span class="line"><span class="string">       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428, 7.0499],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [ 7.0499,  7.0428,  7.0357, ...,  7.0286,  7.0357,  7.0428],</span></span><br><span class="line"><span class="string">       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428,  7.0499],</span></span><br><span class="line"><span class="string">       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>用matplotlib创建了这个二维数组的可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line"><span class="comment"># &lt;matplotlib.colorbar.Colorbar at 0x7f715e3fa630&gt;</span></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</span><br><span class="line"><span class="comment"># &lt;matplotlib.text.Text at 0x7f715d2de748&gt;</span></span><br></pre></td></tr></table></figure>

<p><img alt="img5" data-src="/images/python/4.5.png" class="lazyload"></p>
<h3 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h3><p>假设我们有一个布尔数组和两个值数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>

<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">   .....:           <span class="keyword">for</span> x, y, c <span class="keyword">in</span> zip(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment"># [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]</span></span><br></pre></td></tr></table></figure>

<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁，numpy.where函数是三元表达式x if condition else y的矢量化版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure>

<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。</p>
<p>假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-0.5031, -0.6223, -0.9212, -0.7262],</span></span><br><span class="line"><span class="string">       [ 0.2229,  0.0513, -1.1577,  0.8167],</span></span><br><span class="line"><span class="string">       [ 0.4336,  1.0107,  1.8249, -0.9975],</span></span><br><span class="line"><span class="string">       [ 0.8506, -0.1316,  0.9124,  0.1882]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-2, -2, -2, -2],</span></span><br><span class="line"><span class="string">       [ 2,  2, -2,  2],</span></span><br><span class="line"><span class="string">       [ 2,  2,  2, -2],</span></span><br><span class="line"><span class="string">       [ 2, -2,  2,  2]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
</blockquote>
<h3 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h3><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">arr.mean()</span><br><span class="line"><span class="comment"># 0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">np.mean(arr)</span><br><span class="line"><span class="comment"># 0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">arr.sum()</span><br><span class="line"><span class="comment"># 3.9214102239996507</span></span><br><span class="line"></span><br><span class="line">arr.mean(axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([ 1.022 ,  0.1875, -0.502 , -0.0881,  0.3611])</span></span><br><span class="line"></span><br><span class="line">arr.sum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># array([ 3.1693, -2.6345,  2.2381,  1.1486])</span></span><br></pre></td></tr></table></figure>

<p>arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 列累加</span></span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 0,  1,  2],</span></span><br><span class="line"><span class="string">       [ 3,  5,  7],</span></span><br><span class="line"><span class="string">       [ 9, 12, 15]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 行累加</span></span><br><span class="line">arr.cumsum(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[ 0,  1,  3],</span></span><br><span class="line"><span class="string">       [ 3,  7,  12],</span></span><br><span class="line"><span class="string">       [ 6, 13, 21]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 行累乘</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[  0,   0,   0],</span></span><br><span class="line"><span class="string">       [  3,  12,  60],</span></span><br><span class="line"><span class="string">       [  6,  42, 336]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>下表列出了全部的基本数组统计方法。<br><img alt="img6-1" data-src="/images/python/4.6.1.png" class="lazyload"><br><img alt="img6-2" data-src="/images/python/4.6.2.png" class="lazyload"></p>
<h3 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h3><p>sum经常被用来对布尔型数组中的True值计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">(arr &gt; <span class="number">0</span>).sum() <span class="comment"># Number of positive values</span></span><br><span class="line"><span class="comment"># 42</span></span><br></pre></td></tr></table></figure>

<p>any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">bools.any() <span class="comment"># True</span></span><br><span class="line">bools.all() <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([ 0.6095, -0.4938,  1.24  , -0.1357,  1.43  , -0.8469])</span></span><br><span class="line"></span><br><span class="line">arr.sort()<span class="comment"># 多维数组也可以</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># array([-0.8469, -0.4938, -0.1357,  0.6095,  1.24  ,  1.43  ])</span></span><br></pre></td></tr></table></figure>

<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.6033,  1.2636, -0.2555],</span></span><br><span class="line"><span class="string">       [-0.4457,  0.4684, -0.9616],</span></span><br><span class="line"><span class="string">       [-1.8245,  0.6254,  1.0229],</span></span><br><span class="line"><span class="string">       [ 1.1074,  0.0909, -0.3501],</span></span><br><span class="line"><span class="string">       [ 0.218 , -0.8948, -1.7415]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="number">1</span>) <span class="comment"># 按行排列</span></span><br><span class="line">arr</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-0.2555,  0.6033,  1.2636],</span></span><br><span class="line"><span class="string">       [-0.9616, -0.4457,  0.4684],</span></span><br><span class="line"><span class="string">       [-1.8245,  0.6254,  1.0229],</span></span><br><span class="line"><span class="string">       [-0.3501,  0.0909,  1.1074],</span></span><br><span class="line"><span class="string">       [-1.7415, -0.8948,  0.218 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h3><p>最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line"></span><br><span class="line">np.unique(names)</span><br><span class="line"><span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')</span></span><br><span class="line"></span><br><span class="line">ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">np.unique(ints)</span><br><span class="line"><span class="comment"># array([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<p>拿跟np.unique等价的纯Python代码来对比一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(set(names))</span><br><span class="line"><span class="comment"># ['Bob', 'Joe', 'Will']</span></span><br></pre></td></tr></table></figure>

<p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<p>np.intersect1d计算x,y的公共元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.intersect1d([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># array([2, 4])</span></span><br></pre></td></tr></table></figure>

<p><img alt="img7" data-src="/images/python/4.7.png" class="lazyload"></p>
<h1 id="四、用于数组的文件输入输出"><a href="#四、用于数组的文件输入输出" class="headerlink" title="四、用于数组的文件输入输出"></a>四、用于数组的文件输入输出</h1><p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr)</span><br></pre></td></tr></table></figure>

<p>通过np.load读取磁盘上的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>

<p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line"></span><br><span class="line">arch[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p>如果要将数据压缩，可以使用numpy.savez_compressed：</p>
<figure class="highlight python"><figcaption><span>np.savez_compressed('arrays_compressed.npz', a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment"># 五、线性代数</span></span><br><span class="line">NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</span><br><span class="line">```python</span><br><span class="line">x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line">y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [<span class="number">-1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">x.dot(y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  28.,   64.],</span></span><br><span class="line"><span class="string">       [  67.,  181.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>x.dot(y)等价于np.dot(x, y)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.dot(x, y)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([[  28.,   64.],</span></span><br><span class="line"><span class="string">       [  67.,  181.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>@符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x @ np.ones(<span class="number">3</span>) <span class="comment"># array([  6.,  15.])</span></span><br></pre></td></tr></table></figure>

<p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line">X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">mat = X.T.dot(X)</span><br><span class="line">inv(mat)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  933.1189,   871.8258, -1417.6902, -1460.4005,  1782.1391],</span></span><br><span class="line"><span class="string">       [  871.8258,   815.3929, -1325.9965, -1365.9242,  1666.9347],</span></span><br><span class="line"><span class="string">       [-1417.6902, -1325.9965,  2158.4424,  2222.0191, -2711.6822],</span></span><br><span class="line"><span class="string">       [-1460.4005, -1365.9242,  2222.0191,  2289.0575, -2793.422 ],</span></span><br><span class="line"><span class="string">       [ 1782.1391,  1666.9347, -2711.6822, -2793.422 ,  3409.5128]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">mat.dot(inv(mat))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 1.,  0., -0., -0., -0.],</span></span><br><span class="line"><span class="string">       [-0.,  1.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  1.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [-0.,  0.,  0.,  1., -0.],</span></span><br><span class="line"><span class="string">       [-0.,  0.,  0.,  0.,  1.]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">q, r = qr(mat)</span><br><span class="line">r</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-1.6914,  4.38  ,  0.1757,  0.4075, -0.7838],</span></span><br><span class="line"><span class="string">       [ 0.    , -2.6436,  0.1939, -3.072 , -1.0702],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    , -0.8138,  1.5414,  0.6155],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    , -2.6445, -2.1669],</span></span><br><span class="line"><span class="string">       [ 0.    ,  0.    ,  0.    ,  0.    ,  0.0002]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>下表列出了一些最常用的线性代数函数。<br><img alt="img8" data-src="/images/python/4.8.png" class="lazyload"></p>
<h1 id="六、伪随机数生成"><a href="#六、伪随机数生成" class="headerlink" title="六、伪随机数生成"></a>六、伪随机数生成</h1><p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。</p>
<p>例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">samples</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.5732,  0.1933,  0.4429,  1.2796],</span></span><br><span class="line"><span class="string">       [ 0.575 ,  0.4339, -0.7658, -1.237 ],</span></span><br><span class="line"><span class="string">       [-0.5367,  1.8545, -0.92  , -0.1082],</span></span><br><span class="line"><span class="string">       [ 0.1525,  0.9435, -1.0953, -0.144 ]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">%timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># 1.77 s +- 126 ms per loop (mean +- std. dev. of 7 runs, 1 loop each)</span></span><br><span class="line"></span><br><span class="line">%timeit np.random.normal(size=N)</span><br><span class="line"><span class="comment"># 61.7 ms +- 1.32 ms per loop (mean +- std. dev. of 7 runs, 10 loops each)</span></span><br></pre></td></tr></table></figure>

<p>这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure>

<p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">array([ 0.4714, -1.191 ,  1.4327, -0.3127, -0.7206,  0.8872,  0.8596,</span></span><br><span class="line"><span class="string">       -0.6365,  0.0157, -2.2427])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>下表列出了numpy.random中的部分函数。<br><img alt="img9-1" data-src="/images/python/4.9.1.png" class="lazyload"><br><img alt="img9-2" data-src="/images/python/4.9.2.png" class="lazyload"></p>
<h1 id="七、示例：随机漫步"><a href="#七、示例：随机漫步" class="headerlink" title="七、示例：随机漫步"></a>七、示例：随机漫步</h1><p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">   .....: position = <span class="number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="number">1000</span></span><br><span class="line">   .....: <span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">   .....:     step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br></pre></td></tr></table></figure>

<p>下图根据前100个随机漫步值生成的折线图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(walk[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure>

<p><img alt="img10" data-src="/images/python/4.10.png" class="lazyload"><br>我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">walk = steps.cumsum()</span><br><span class="line">walk.min() <span class="comment"># -3</span></span><br><span class="line">walk.max() <span class="comment"># 31</span></span><br></pre></td></tr></table></figure>

<p>假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(np.abs(walk) &gt;= <span class="number">10</span>).argmax() <span class="comment"># 37</span></span><br></pre></td></tr></table></figure>

<h3 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h3><p>如果你希望模拟多个随机漫步过程（比如5000个），只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=(nwalks,nsteps))</span><br><span class="line">steps = np.where(draws&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[  1,   0,   1, ...,   8,   7,   8],</span></span><br><span class="line"><span class="string">       [  1,   0,  -1, ...,  34,  33,  32],</span></span><br><span class="line"><span class="string">       [  1,   0,  -1, ...,   4,   5,   4],</span></span><br><span class="line"><span class="string">       ..., </span></span><br><span class="line"><span class="string">       [  1,   2,   1, ...,  24,  25,  26],</span></span><br><span class="line"><span class="string">       [  1,   2,   3, ...,  14,  13,  14],</span></span><br><span class="line"><span class="string">       [ -1,  -2,  -3, ..., -24, -23, -22]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">walk.max() <span class="comment"># 138</span></span><br><span class="line">walk.min() <span class="comment"># -133</span></span><br></pre></td></tr></table></figure>

<p>计算30或－30的最小穿越时间，不是5000个过程都到达了30，用any方法来对此进行检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hits30=(np.abs(walk)&gt;=<span class="number">30</span>).any(<span class="number">1</span>)</span><br><span class="line">hits30.sum() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line"><span class="comment"># 3410</span></span><br></pre></td></tr></table></figure>

<p>这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crossing_times = (np.abs(walk[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean() <span class="comment"># 498.88973607038122</span></span><br></pre></td></tr></table></figure>

<p>用其他分布方式得到漫步数据，比如normal用于生成指定均值和标准差的正态分布数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steps = np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">0.25</span>,size=(nwalks,nsteps))</span><br><span class="line">walk = steps.cumsum(<span class="number">1</span>)</span><br><span class="line">hits30=(np.abs(walk)&gt;=<span class="number">30</span>).any(<span class="number">1</span>)</span><br><span class="line">crossing_times = (np.abs(walk[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean() <span class="comment"># 999.0</span></span><br></pre></td></tr></table></figure>

<p>本节参考自《利用python进行数据分析》第四章，阅读链接：<a href="https://wizardforcel.gitbooks.io/pyda-2e/content/4.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/pyda-2e/content/4.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">PalmLand</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://palmland.github.io/2019/07/14/python-04Numpy/">https://palmland.github.io/2019/07/14/python-04Numpy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/07/15/python-05Pandas/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Python-05Pandas</span></div></a></div><div class="next-post pull_right"><a href="/2019/07/11/python-03高级特性/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Python-03高级特性</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/16/python-06Matplotlib/" title="Python-06Matplotlib"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Python-06Matplotlib</div></a></div><div class="relatedPosts_item"><a href="/2019/05/26/python-02函数/" title="Python-02函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Python-02函数</div></a></div><div class="relatedPosts_item"><a href="/2019/07/11/python-03高级特性/" title="Python-03高级特性"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Python-03高级特性</div></a></div><div class="relatedPosts_item"><a href="/2019/05/24/python-01基础/" title="Python-01基础"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Python-01基础</div></a></div><div class="relatedPosts_item"><a href="/2019/07/15/python-05Pandas/" title="Python-05Pandas"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Python-05Pandas</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By PalmLand</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>